---
title: Molecules
description: Molecules component for React Native.
---

### üì¶ Installation


```bash
npx rn-glow add molecules
```

### ‚öôÔ∏è Types
#### AnimatedMaskedText.types.ts

```ts
import type { StyleProp, TextStyle } from "react-native";

export interface AnimatedMaskedTextProps {
  children: string;
  speed?: number;
  /**
   *
   *
   * @type {string[]}
   * @memberof AnimatedMaskedTextProps
   * @description The first color in the array is always going to be "transparent."
   */
  colors?: string[];
  baseTextColor?: string;
  style?: StyleProp<TextStyle>;
}
```

#### BottomSheet.types.ts

```ts
import { ReactNode } from "react";

export interface BottomSheetProps {
  children: ReactNode;
  backgroundColor?: string;
  indicatorColor?: string;
  // isVisible: boolean;
  // onClose: () => void;
  // snapPoints?: number[];
  // initialSnapPoint?: number;
}
```

#### Breadcrumbs.types.ts

```ts
import type { ReactNode } from "react";

export type BreadcrumbItemProps = {
  children: ReactNode;
  onPress?: () => void;
  isCurrent?: boolean;
  tint?: string;
  currentTint?: string;
  className?: string;
};

export type BreadcrumbsListProps = {
  children: ReactNode;
};

export type BreadcrumbsSeparatorProps = {
  children?: ReactNode;
};

export type BreadcrumbsProps = {
  children: ReactNode;
  style?: any;
};
```

#### Card.types.ts

```ts
import type { StyleProp, ViewStyle } from "react-native";
/**
 *
 * @export
 * @interface CardProps
 */
export interface CardProps {
  /**
   * The content of the card.
   */
  children: React.ReactNode;

  /**
   * The style of the card.
   */
  style?: StyleProp<ViewStyle>;

  /**
   * The class name of the card.
   */
  className?: string;
  /**
   * The radius of the card.
   */
  /**
   * The image of the card wrapper.
   */
  image?: string;

  /**
   * Wthether to use the image or not.
   * @type {boolean}
   */
  useImage?: boolean;
}

export interface CardWrapperProps {
  /**
   * The content of the card wrapper.
   */
  children: React.ReactNode;

  /**
   * The style of the card wrapper.
   */
  style?: StyleProp<ViewStyle>;

  /**
   * The class name of the card wrapper.
   */
  className?: string;
}
```

#### Chip.types.ts

```ts
import type { SFSymbol } from "expo-symbols";
import type { StyleProp, ViewStyle } from "react-native";

export interface ChipItem {
  label: string;
  icon: SFSymbol;
  activeIcon?: SFSymbol;
  activeColor?: string;
}

export interface ChipGroupProps<T> {
  chips: T[];
  selectedIndex?: number;
  onChange?: (index: number) => void;
  containerStyle?: StyleProp<ViewStyle>;
}

export interface AnimatedChipProps extends ChipItem {
  isActive: boolean;
  onPress: () => void;
}
```

#### List.types.ts

```ts
import type { ReactNode } from "react";

export interface ListItemType {
  _name?: string;
  title?: string;
  subtitle?: string;
  leadingIcon?: () => ReactNode;
  trailingIcon?: () => ReactNode;
  onPress?: () => void;
  destructive?: boolean;
}
```

#### Circle.types.ts

```ts

```

#### OrbitingDots.types.ts

```ts

```

#### PlusingDots.types.ts

```ts
interface Gradient {
  from?: string;
  to?: string;
}

export interface PulsingDotsProps {
  dotCount?: number;
  radius?: number;
  spacing?: number;
  duration?: number;
  color?: string;
  gradient?: Gradient[];
}
```

#### SpinnerArc.types.ts

```ts
export interface SpinnerArcProps {
  size?: number;
  colorStart?: string;
  colorEnd?: string;
  strokeWidth?: number;
  speed?: number;
  backgroundColor?: string;
  arcLength?: number;
}
```

#### SegmentSpinner.types.ts

```ts
export interface SpinnerSegmentsProps {
  size?: number;
  color?: string;
  segmentColor?: string;
  centerColor?: string;
  speed?: number;
  segmentCount?: number;
  pulseSize?: number;
}
```

#### Pagination.types.ts

```ts
import type { StyleProp, ViewProps, ViewStyle } from "react-native";

export interface PaginationProps extends ViewProps {
  activeIndex: number;
  totalItems: number;
  inactiveColor?: string;
  activeColor?: string;
  currentColor?: string;
  containerStyle?: StyleProp<ViewStyle>;
  dotSize?: number;
  borderRadius?: number;
  dotContainer?: number;
  onIndexChange?: (index: number) => void;
}
```

#### SeekBar.types.ts

```ts
export interface SeekBarProps {
  value: number;
  onValueChange: (value: number) => void;
  width?: number;
  height?: number;
  activeHeight?: number;
  activeColor?: string;
  inactiveColor?: string;
  disabled?: boolean;
  tapToSeek?: boolean;
}
```

#### Shimmer.types.ts

```ts
import type { StyleProp, ViewStyle } from "react-native";
export type ShimmerEffectProps = {
  isLoading?: boolean;
  shimmerColors?: string[];
  duration?: number;
  className?: string;
  style?: ViewStyle;
  variant?: "shimmer" | "pulse";
  direction?: ShimmerDirection;
};
export type ShimmerDirection =
  | "leftToRight"
  | "rightToLeft"
  | "topToBottom"
  | "bottomToTop";
```

#### Stepper.types.ts

```ts
import type { ViewStyle } from "react-native";
import type { StepperContextProps } from "./context/types";

export interface StepperProps extends Partial<StepperContextProps> {
  children: React.ReactNode;
  style?: ViewStyle;
  containerStyle?: ViewStyle;
  defaultValue?: number;
}
```

#### TimelineView.types.ts

```ts
import { Feather } from "@expo/vector-icons";
import { StyleProp, View, TextStyle, ViewStyle } from "react-native";

export interface TimelineItem {
  id: string | number;
  title: string;
  description?: string;
  timestamp?: string;
  icon?: keyof typeof Feather.glyphMap;
  status?: "complete" | "current" | "upcoming";
  meta?: string;
  children?: React.ReactNode;
  childrenContainer?: StyleProp<ViewStyle>;
}

export interface TimelineProps {
  items: TimelineItem[];
  activeColor?: string;
  inactiveColor?: string;
  animated?: boolean;
  animationType?: "bounce" | "spring" | "rotate" | "fade" | "scale";
  onItemPress?: (item: TimelineItem) => void;
  containerStyle?: ViewStyle;
  metaContainerStyle?: StyleProp<ViewStyle>;
  titleStyle?: TextStyle;
  descriptionStyle?: TextStyle;
  timestampStyle?: TextStyle;
  lineWidth?: number;
  iconSize?: number;
  metaTextStyle?: StyleProp<TextStyle>;
}
```

#### Toast.types.ts

```ts
export type ToastType = "default" | "success" | "error" | "warning" | "info";

export type ToastPosition = "top" | "bottom";

export interface ToastProps {
  children: React.ReactNode;
}
export interface ToastOptions {
  duration?: number;
  type?: ToastType;
  position?: ToastPosition;
  onClose?: () => void;
  action?: {
    label?: string;
    onPress?: () => void;
  };
}

export interface Toast {
  id: string;
  content: React.ReactNode | string;
  options: Required<ToastOptions>;
}

export interface ToastContextValue {
  toasts: Toast[];
  show: (content: React.ReactNode | string, options?: ToastOptions) => string;
  update: (
    id: string,
    content: React.ReactNode | string,
    options?: ToastOptions
  ) => void;
  dismiss: (id: string) => void;
  dismissAll: () => void;
}
```

### üíª Components
#### Accordian.tsx

```tsx
import React, { useState, ReactNode } from "react";
import { View, StyleSheet } from "react-native";

export const Accordion = ({
  children,
  className,
}: {
  children: ReactNode;
  className?: string;
}) => {
  const [activeIndex, setActiveIndex] = useState<number | null>(null);

  const handleToggle = (index: number) => {
    setActiveIndex(activeIndex === index ? null : index);
  };

  return (
    <View style={styles.accordion}>
      {React.Children.map(children, (child, index) => {
        return React.cloneElement(child as React.ReactElement<any>, {
          isActive: index === activeIndex,
          onToggle: () => handleToggle(index),
        });
      })}
    </View>
  );
};

const styles = StyleSheet.create({
  accordion: {
    width: "100%",
  },
});
```

#### AnimatedMaskedText.tsx

```tsx
import React, { useEffect, useRef } from "react";
import { Animated, Text, StyleSheet, Easing, View } from "react-native";
import { LinearGradient } from "expo-linear-gradient";
import MaskedView from "@react-native-masked-view/masked-view";
import type { AnimatedMaskedTextProps } from "./AnimatedMaskedText.types";

export const AnimatedMaskedText: React.FC<AnimatedMaskedTextProps> = ({
  children,
  style,
  speed = 1,
  colors = ["transparent", "rgba(255,255,255,1)", "transparent"],
  baseTextColor = "#000000", // Add base text color prop
}) => {
  const shimmerTranslate = useRef(new Animated.Value(0)).current;
  const [textWidth, setTextWidth] = React.useState(0);
  const [textHeight, setTextHeight] = React.useState(0);

  useEffect(() => {
    const animate = () => {
      shimmerTranslate.setValue(-1);
      Animated.loop(
        Animated.timing(shimmerTranslate, {
          toValue: 1,
          duration: 2000 / speed,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
      ).start();
    };
    animate();
  }, [shimmerTranslate, speed]);

  const translateX = shimmerTranslate.interpolate({
    inputRange: [-1, 1],
    outputRange: [-textWidth * 2.2, textWidth * 2.5],
  });

  return (
    <View style={{ position: "relative" }}>
      {/* Base text layer - visible text */}
      <Text
        style={[styles.text, style, { color: baseTextColor }]}
        onTextLayout={(e) => {
          const { width, height } = e.nativeEvent.lines[0];
          setTextWidth(width);
          setTextHeight(height);
        }}
      >
        {children}
      </Text>

      {/* Shimmer overlay */}
      {textWidth > 0 && (
        <MaskedView
          style={[
            StyleSheet.absoluteFill,
            {
              width: textWidth,
              height: textHeight || 50,
            },
          ]}
          maskElement={
            <Text style={[styles.text, style, { color: "white" }]}>
              {children}
            </Text>
          }
        >
          <Animated.View
            style={[
              {
                flexDirection: "row",
                transform: [{ translateX }],
                opacity: shimmerTranslate.interpolate({
                  inputRange: [-1, 1],
                  outputRange: [0.3, 1],
                }),
              },
            ]}
          >
            <LinearGradient
              colors={colors as any}
              start={{ x: 0, y: 0 }}
              end={{ x: 1, y: 0 }}
              style={{
                width: textWidth * 3,
                height: textHeight || 50,
              }}
            />
          </Animated.View>
        </MaskedView>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  text: {
    fontSize: 20,
    fontWeight: "bold",
  },
});
```

#### BottomSheet.tsx

```tsx
import React, { useEffect, useRef } from "react";
import { StyleSheet, Text } from "react-native";
import BottomSheetGorhom, { BottomSheetView } from "@gorhom/bottom-sheet";
import { GestureHandlerRootView } from "react-native-gesture-handler";
import { BottomSheetProps } from "./BottomSheet.types";

export const BottomSheet: React.FC<BottomSheetProps> = ({
  children,
  backgroundColor,
  indicatorColor,
}) => {
  const ref = useRef<BottomSheetGorhom>(null);
  useEffect(() => {
    ref.current?.expand();
  }, []);

  return (
    <>
      <GestureHandlerRootView
        style={{
          flex: 1,
        }}
      >
        <BottomSheetGorhom
          backgroundStyle={{
            backgroundColor,
          }}
          ref={ref}
          index={0}
          snapPoints={["10%", "50%"]}
          handleIndicatorStyle={{
            backgroundColor: indicatorColor,
            width: 60,
            height: 4.5,
          }}
          handleStyle={{
            backgroundColor,
          }}
        >
          <BottomSheetView
            style={[
              [
                styles.contentContainer,
                {
                  backgroundColor,
                },
              ],
            ]}
          >
            {children}
          </BottomSheetView>
        </BottomSheetGorhom>
      </GestureHandlerRootView>
    </>
  );
};

const styles = StyleSheet.create({
  contentContainer: { flex: 1 },
});
```

#### BreadcrumbsList.tsx

```tsx
import React from "react";
import { View, StyleSheet } from "react-native";
import type { BreadcrumbsListProps } from "./Breadcrumbs.types";

export const BreadcrumbsList: React.FC<BreadcrumbsListProps> = ({
  children,
}) => {
  return <View style={styles.list}>{children}</View>;
};

const styles = StyleSheet.create({
  list: {
    flexDirection: "row",
    alignItems: "center",
    flexWrap: "wrap",
  },
});
```

#### Card.tsx

```tsx
import React, { forwardRef } from "react";
import {
  View,
  Text,
  TouchableOpacity,
  ViewStyle,
  TextStyle,
  StyleSheet,
  Pressable,
} from "react-native";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  withRepeat,
  Easing,
} from "react-native-reanimated";

interface CardProps {
  children?: React.ReactNode;
  className?: string;
  style?: ViewStyle;
  variant?: "default" | "elevated" | "outlined" | "ghost";
  size?: "sm" | "md" | "lg" | "xl";
  interactive?: boolean;
  pressable?: boolean;
  disabled?: boolean;
  loading?: boolean;
  onPress?: () => void;
  onLongPress?: () => void;
  animationType?: "scale" | "fade" | "slide" | "bounce" | "none";
  animationDuration?: number;
  borderRadius?: number;
  shadow?: boolean;
  shadowIntensity?: "sm" | "md" | "lg" | "xl";
  backgroundColor?: string;
  borderColor?: string;
  borderWidth?: number;
}

interface CardHeaderProps {
  children?: React.ReactNode;
  style?: ViewStyle;
  spacing?: "sm" | "md" | "lg";
  align?: "left" | "center" | "right";
}

interface CardTitleProps {
  children: React.ReactNode;
  style?: TextStyle;
  size?: "sm" | "md" | "lg" | "xl";
  weight?: "normal" | "medium" | "semibold" | "bold";
  color?: string;
  numberOfLines?: number;
}

interface CardDescriptionProps {
  children: React.ReactNode;
  style?: TextStyle;
  size?: "xs" | "sm" | "md";
  color?: string;
  numberOfLines?: number;
}

interface CardContentProps {
  children?: React.ReactNode;
  style?: ViewStyle;
  spacing?: "sm" | "md" | "lg";
}

interface CardFooterProps {
  children?: React.ReactNode;
  style?: ViewStyle;
  spacing?: "sm" | "md" | "lg";
  justify?: "start" | "center" | "end" | "between" | "around";
}

const theme = {
  colors: {
    background: "#0a0a0a",
    card: "#1a1a1a",
    cardElevated: "#262626",
    cardOutlined: "#1a1a1a",
    cardGhost: "transparent",
    border: "#333333",
    borderLight: "#404040",
    text: "#ffffff",
    textMuted: "#a3a3a3",
    textSecondary: "#737373",
    primary: "#3b82f6",
    primaryForeground: "#ffffff",
    destructive: "#ef4444",
    destructiveForeground: "#ffffff",
  },
  spacing: {
    sm: 12,
    md: 16,
    lg: 20,
    xl: 24,
  },
  borderRadius: {
    sm: 6,
    md: 8,
    lg: 12,
    xl: 16,
  },
  fontSize: {
    xs: 12,
    sm: 14,
    md: 16,
    lg: 18,
    xl: 20,
    "2xl": 24,
  },
  fontWeight: {
    normal: "400",
    medium: "500",
    semibold: "600",
    bold: "700",
  },
  shadows: {
    sm: {
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 1 },
      shadowOpacity: 0.05,
      shadowRadius: 2,
      elevation: 1,
    },
    md: {
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.1,
      shadowRadius: 6,
      elevation: 3,
    },
    lg: {
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 10 },
      shadowOpacity: 0.15,
      shadowRadius: 15,
      elevation: 5,
    },
    xl: {
      shadowColor: "#000",
      shadowOffset: { width: 0, height: 20 },
      shadowOpacity: 0.2,
      shadowRadius: 25,
      elevation: 8,
    },
  },
};

const AnimatedTouchableOpacity =
  Animated.createAnimatedComponent(TouchableOpacity);
const AnimatedPressable = Animated.createAnimatedComponent(Pressable);

export const Card = forwardRef<View, CardProps>(
  (
    {
      children,
      style,
      variant = "default",
      size = "md",
      interactive = false,
      pressable = false,
      disabled = false,
      loading = false,
      onPress,
      onLongPress,
      animationType = "scale",
      animationDuration = 150,
      borderRadius,
      shadow = true,
      shadowIntensity = "md",
      backgroundColor,
      borderColor,
      borderWidth,
      ...props
    },
    ref,
  ) => {
    const scale = useSharedValue(1);
    const opacity = useSharedValue(1);
    const translateY = useSharedValue(0);

    const getVariantStyles = () => {
      switch (variant) {
        case "elevated":
          return {
            backgroundColor: backgroundColor || theme.colors.cardElevated,
            ...theme.shadows[shadowIntensity],
          };
        case "outlined":
          return {
            backgroundColor: backgroundColor || theme.colors.cardOutlined,
            borderWidth: borderWidth || 1,
            borderColor: borderColor || theme.colors.border,
          };
        case "ghost":
          return {
            backgroundColor: backgroundColor || theme.colors.cardGhost,
            borderWidth: 0,
          };
        default:
          return {
            backgroundColor: backgroundColor || theme.colors.card,
            ...(shadow ? theme.shadows[shadowIntensity] : {}),
          };
      }
    };

    const getSizeStyles = () => {
      switch (size) {
        case "sm":
          return { padding: theme.spacing.sm };
        case "lg":
          return { padding: theme.spacing.lg };
        case "xl":
          return { padding: theme.spacing.xl };
        default:
          return { padding: theme.spacing.md };
      }
    };

    const animatedStyle = useAnimatedStyle(() => {
      const scaleValue = animationType === "scale" ? scale.value : 1;
      const opacityValue = animationType === "fade" ? opacity.value : 1;
      const translateYValue =
        animationType === "slide" || animationType === "bounce"
          ? translateY.value
          : 0;

      return {
        transform: [{ scale: scaleValue }, { translateY: translateYValue }],
        opacity: opacityValue,
      };
    });

    const handlePressIn = () => {
      if (disabled || loading) return;

      switch (animationType) {
        case "scale":
          scale.value = withSpring(0.95, { damping: 15, stiffness: 300 });
          break;
        case "fade":
          opacity.value = withTiming(0.7, { duration: animationDuration });
          break;
        case "slide":
          translateY.value = withSpring(2, { damping: 15, stiffness: 300 });
          break;
        case "bounce":
          scale.value = withSpring(0.98, { damping: 10, stiffness: 400 });
          translateY.value = withSpring(1, { damping: 10, stiffness: 400 });
          break;
      }
    };

    const handlePressOut = () => {
      if (disabled || loading) return;

      switch (animationType) {
        case "scale":
          scale.value = withSpring(1, { damping: 15, stiffness: 300 });
          break;
        case "fade":
          opacity.value = withTiming(1, { duration: animationDuration });
          break;
        case "slide":
          translateY.value = withSpring(0, { damping: 15, stiffness: 300 });
          break;
        case "bounce":
          scale.value = withSpring(1, { damping: 10, stiffness: 400 });
          translateY.value = withSpring(0, { damping: 10, stiffness: 400 });
          break;
      }
    };

    const cardStyles = [
      styles.card,
      getVariantStyles(),
      getSizeStyles(),
      {
        borderRadius: borderRadius || theme.borderRadius.lg,
        opacity: disabled ? 0.5 : 1,
      },
      style,
    ];

    if (pressable || onPress || onLongPress) {
      return (
        <AnimatedPressable
          ref={ref}
          style={[cardStyles, animatedStyle]}
          onPressIn={handlePressIn}
          onPressOut={handlePressOut}
          onPress={onPress}
          onLongPress={onLongPress}
          disabled={disabled || loading}
          {...props}
        >
          {loading && <LoadingOverlay />}
          {children}
        </AnimatedPressable>
      );
    }

    if (interactive) {
      return (
        <AnimatedTouchableOpacity
          ref={ref}
          style={[cardStyles, animatedStyle]}
          onPressIn={handlePressIn}
          onPressOut={handlePressOut}
          onPress={onPress}
          onLongPress={onLongPress}
          disabled={disabled || loading}
          activeOpacity={1}
          {...props}
        >
          {loading && <LoadingOverlay />}
          {children}
        </AnimatedTouchableOpacity>
      );
    }

    return (
      <Animated.View ref={ref} style={[cardStyles, animatedStyle]} {...props}>
        {loading && <LoadingOverlay />}
        {children}
      </Animated.View>
    );
  },
);

export const CardHeader: React.FC<CardHeaderProps> = ({
  children,
  style,
  spacing = "md",
  align = "left",
}) => {
  const spacingValue = theme.spacing[spacing];
  const alignItems =
    align === "center"
      ? "center"
      : align === "right"
        ? "flex-end"
        : "flex-start";

  return (
    <View
      style={[
        styles.cardHeader,
        { paddingBottom: spacingValue, alignItems },
        style,
      ]}
    >
      {children}
    </View>
  );
};

export const CardTitle: React.FC<CardTitleProps> = ({
  children,
  style,
  size = "lg",
  weight = "semibold",
  color,
  numberOfLines,
}) => {
  return (
    <Text
      style={[
        styles.cardTitle,
        {
          fontSize: theme.fontSize[size],
          fontWeight: theme.fontWeight[weight],
          color: color || theme.colors.text,
        } as any,
        style,
      ]}
      numberOfLines={numberOfLines}
    >
      {children}
    </Text>
  );
};

export const CardDescription: React.FC<CardDescriptionProps> = ({
  children,
  style,
  size = "sm",
  color,
  numberOfLines,
}) => {
  return (
    <Text
      style={[
        styles.cardDescription,
        {
          fontSize: theme.fontSize[size],
          color: color || theme.colors.textMuted,
        },
        style,
      ]}
      numberOfLines={numberOfLines}
    >
      {children}
    </Text>
  );
};

export const CardContent: React.FC<CardContentProps> = ({
  children,
  style,
  spacing = "md",
}) => {
  const spacingValue = theme.spacing[spacing];

  return (
    <View
      style={[styles.cardContent, { paddingVertical: spacingValue }, style]}
    >
      {children}
    </View>
  );
};

export const CardFooter: React.FC<CardFooterProps> = ({
  children,
  style,
  spacing = "md",
  justify = "start",
}) => {
  const spacingValue = theme.spacing[spacing];
  const justifyContent = {
    start: "flex-start",
    center: "center",
    end: "flex-end",
    between: "space-between",
    around: "space-around",
  }[justify] as any;

  return (
    <View
      style={[
        styles.cardFooter,
        {
          paddingTop: spacingValue,
          justifyContent,
        },
        style,
      ]}
    >
      {children}
    </View>
  );
};

const LoadingOverlay: React.FC = () => {
  const rotation = useSharedValue(0);

  React.useEffect(() => {
    rotation.value = withRepeat(
      withTiming(360, {
        duration: 1000,
        easing: Easing.bezier(0.4, 0, 0.2, 1),
      }),
      -1,
      false,
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }],
  }));

  return (
    <View style={styles.loadingOverlay}>
      <Animated.View style={[styles.spinner, animatedStyle]} />
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    borderRadius: theme.borderRadius.lg,
    backgroundColor: theme.colors.card,
  },
  cardHeader: {
    marginBottom: 0,
  },
  cardTitle: {
    fontSize: theme.fontSize.lg,
    fontWeight: theme?.fontWeight?.semibold as any,
    color: theme?.colors?.text,
    marginBottom: 4,
  },
  cardDescription: {
    fontSize: theme.fontSize.sm,
    color: theme.colors.textMuted,
    lineHeight: theme.fontSize.sm * 1.4,
  },
  cardContent: {
    flex: 1,
  },
  cardFooter: {
    flexDirection: "row",
    alignItems: "center",
    marginTop: 0,
  },
  loadingOverlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0, 0, 0, 0.3)",
    justifyContent: "center",
    alignItems: "center",
    borderRadius: theme.borderRadius.lg,
  },
  spinner: {
    width: 24,
    height: 24,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: theme.colors.primary,
    borderTopColor: "transparent",
  },
});
export { theme };
```

#### Sparkle.tsx

```tsx
import React, { useEffect } from "react";
import { View, StyleSheet, Dimensions } from "react-native";
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withTiming,
  withRepeat,
  interpolate,
} from "react-native-reanimated";
import { LinearGradient } from "expo-linear-gradient";
import Svg, { Circle } from "react-native-svg";

const { width } = Dimensions.get("window");
const CARD_WIDTH = width - 40;
const CARD_HEIGHT = 140;

const Sparkles = () => {
  const sparkleY = useSharedValue(0);
  const sparkleOpacity = useSharedValue(1);

  useEffect(() => {
    sparkleY.value = withRepeat(withTiming(1, { duration: 3000 }), -1, false);
    sparkleOpacity.value = withRepeat(
      withTiming(0, { duration: 1500 }),
      -1,
      true
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => {
    const translateY = interpolate(sparkleY.value, [0, 1], [CARD_HEIGHT, -20]);
    return {
      transform: [{ translateY }],
      opacity: sparkleOpacity.value,
    };
  });

  return (
    <Animated.View
      style={[StyleSheet.absoluteFill, animatedStyle, { left: CARD_WIDTH / 2 }]}
      pointerEvents="none"
    >
      <Svg height="20" width="20">
        <Circle cx="10" cy="10" r="2" fill="#fff" />
        <Circle cx="6" cy="14" r="1.5" fill="#aaa" />
        <Circle cx="14" cy="6" r="1" fill="#ccc" />
      </Svg>
    </Animated.View>
  );
};

export const ShimmerCard = () => {
  const shimmerTranslate = useSharedValue(-1);

  useEffect(() => {
    shimmerTranslate.value = withRepeat(
      withTiming(1.5, { duration: 2000 }),
      -1,
      false
    );
  }, []);

  const animatedShimmerStyle = useAnimatedStyle(() => {
    const translateX = interpolate(
      shimmerTranslate.value,
      [-1, 1],
      [-CARD_WIDTH, CARD_WIDTH]
    );

    return {
      transform: [{ translateX }],
    };
  });

  return (
    <View style={styles.container}>
      <View style={styles.card}>
        {/* Shimmer Layer */}
        <Animated.View style={[StyleSheet.absoluteFill, animatedShimmerStyle]}>
          <LinearGradient
            colors={["transparent", "rgba(255,255,255,0.4)", "transparent"]}
            start={{ x: 0, y: 0 }}
            end={{ x: 1, y: 0 }}
            style={[
              StyleSheet.absoluteFill,
              { width: CARD_WIDTH, height: CARD_HEIGHT },
            ]}
          />
        </Animated.View>

        {/* Sparkles Layer */}
        <Sparkles />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  card: {
    width: CARD_WIDTH,
    height: CARD_HEIGHT,
    borderRadius: 20,
    backgroundColor: "#1e1e1e",
    overflow: "hidden",
    flexDirection: "row",
    padding: 16,
    alignItems: "center",
  },
  iconPlaceholder: {
    width: 60,
    height: 60,
    borderRadius: 30,
    backgroundColor: "#333",
    marginRight: 16,
  },
  textBlock: {
    flex: 1,
    justifyContent: "center",
  },
  line: {
    height: 12,
    backgroundColor: "#333",
    borderRadius: 6,
    marginBottom: 10,
  },
});
```

#### AnimatedChip.tsx

```tsx
import { SymbolView } from "expo-symbols";
import React, { useEffect } from "react";
import { Pressable, StyleSheet, ViewStyle } from "react-native";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  interpolateColor,
  withSpring,
} from "react-native-reanimated";
import type { AnimatedChipProps, ChipGroupProps, ChipItem } from "./Chip.types";

export const AnimatedChip = ({
  label,
  icon,
  isActive,
  onPress,
  activeIcon,
  activeColor,
}: AnimatedChipProps) => {
  const progress = useSharedValue<number>(isActive ? 1 : 0);
  const iconOpacity = useSharedValue<number>(isActive ? 1 : 0);
  useEffect(() => {
    progress.value = withTiming<number>(isActive ? 1 : 0, { duration: 500 });
    iconOpacity.value = withTiming<number>(isActive ? 1 : 0.5, {
      duration: 500,
    });
  }, [isActive]);

  const animatedContainerStyle = useAnimatedStyle<ViewStyle>(() => {
    return {
      width: withSpring(isActive ? 140 : 50, {
        damping: 90,
        velocity: 2,
        stiffness: 180,
      }),

      backgroundColor: interpolateColor(
        progress.value,
        [0, 1],
        ["#333333", activeColor!]
      ),
    };
  });

  const animatedIconOpacityStyle = useAnimatedStyle(() => {
    return {
      opacity: iconOpacity.value,
    };
  });

  const animatedTextStyle = useAnimatedStyle(() => {
    return {
      opacity: progress.value,
      transform: [
        {
          translateX: withTiming(isActive ? 0 : -8, { duration: 200 }),
        },
      ],
    };
  });

  return (
    <Pressable onPress={onPress}>
      <Animated.View style={[styles.chip, animatedContainerStyle]}>
        <Animated.View style={[animatedIconOpacityStyle]}>
          <SymbolView
            size={18}
            name={isActive && activeIcon ? activeIcon : icon}
            tintColor={isActive ? "#FFFFFF" : "#AAAAAA"}
          />
        </Animated.View>
        {isActive && (
          <Animated.View>
            <Animated.View style={[styles.labelWrapper, animatedTextStyle]}>
              <Animated.Text style={styles.label}>{label}</Animated.Text>
            </Animated.View>
          </Animated.View>
        )}
      </Animated.View>
    </Pressable>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: "row",
    gap: 8,
    // padding: 12,
  },
  chip: {
    height: 40,
    borderRadius: 100,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    overflow: "hidden",
  },
  labelWrapper: {
    marginLeft: 8,
    minWidth: 60,
  },
  label: {
    fontSize: 14,
    fontWeight: "500",
    color: "#FFFFFF",
  },
});
```

#### Chip.tsx

```tsx
import { SFSymbol, SymbolView } from "expo-symbols";
import React, { useState } from "react";
import { StyleSheet } from "react-native";
import Animated, { LinearTransition } from "react-native-reanimated";
import type { ChipGroupProps, ChipItem } from "./Chip.types";
import { AnimatedChip } from "./AnimatedChip";

export const ChipGroup: React.FC<ChipGroupProps<ChipItem>> = ({
  chips,
  onChange,
  containerStyle,
  selectedIndex,
}) => {
  const [internalIndex, setInternalIndex] = useState(0);
  const activeIndex = selectedIndex ?? internalIndex;

  const handlePress = (index: number) => {
    if (selectedIndex === undefined) {
      setInternalIndex(index);
    }
    onChange?.(index);
  };
  return (
    <Animated.View
      style={[styles.container, containerStyle]}
      layout={LinearTransition}
    >
      {chips.map((item, index) => (
        <AnimatedChip
          key={index}
          label={item.label}
          activeColor={item.activeColor}
          activeIcon={item.activeIcon}
          icon={item.icon}
          isActive={activeIndex === index}
          onPress={() => handlePress(index)}
        />
      ))}
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: "row",
    gap: 8,
  },
});
```

#### List.tsx

```tsx
import { Fragment, type ReactNode } from "react";
import { ListItemType } from "./List.types";
import { Text, View } from "react-native";

export const ListItem: React.FC<ListItemType> &
  React.FunctionComponent<ListItemType> = ({
  _name,
  leadingIcon,
  onPress,
  subtitle,
  title,
  trailingIcon,
  destructive,
}): JSX.Element & ReactNode => {
  return (
    <Fragment>
      <View className="p-3">
        <View className="flex-row items-center">
          {leadingIcon && leadingIcon()}
          <View className="flex-1 justify-center ml-4">
            <Text
              className={
                destructive
                  ? "text-red-500 font-medium text-lg"
                  : "text-white font-medium text-lg"
              }
            >
              {title}
            </Text>
            <Text className="text-gray-300 text-sm">{subtitle}</Text>
          </View>
          <View className="items-center justfy-center">
            {trailingIcon && trailingIcon()}
          </View>
        </View>
      </View>
    </Fragment>
  );
};
```

#### Circle.Indiactor.tsx

```tsx
// components/LoadingIndicator.tsx
import React, { useEffect } from "react";
import { View, StyleSheet, ViewStyle } from "react-native";
import Svg, { Circle } from "react-native-svg";
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withRepeat,
  withTiming,
  Easing,
} from "react-native-reanimated";

const AnimatedCircle = Animated.createAnimatedComponent(Circle);

export interface CircleLoadingIndicatorProps {
  dotColor?: string;
  dotRadius?: number;
  dotSpacing?: number;
  duration?: number;
  style?: ViewStyle;
}

export const CircleLoadingIndicator: React.FC<CircleLoadingIndicatorProps> = ({
  dotColor = "#007AFF",
  dotRadius = 6,
  dotSpacing = 20,
  duration = 450,
  style,
}) => {
  const progress1 = useSharedValue(0);
  const progress2 = useSharedValue(0);
  const progress3 = useSharedValue(0);

  useEffect(() => {
    progress1.value = withRepeat(
      withTiming(1, {
        duration,
        easing: Easing.inOut(Easing.ease),
      }),
      -1,
      true,
    );

    setTimeout(() => {
      progress2.value = withRepeat(
        withTiming(1, {
          duration,
          easing: Easing.inOut(Easing.ease),
        }),
        -1,
        true,
      );
    }, duration / 3);

    setTimeout(
      () => {
        progress3.value = withRepeat(
          withTiming(1, {
            duration,
            easing: Easing.inOut(Easing.ease),
          }),
          -1,
          true,
        );
      },
      (2 * duration) / 3,
    );
  }, [duration]);

  const jumpHeight = dotRadius * 0.85;

  const animatedProps1 = useAnimatedProps(() => ({
    cy: 12 - progress1.value * jumpHeight,
  }));
  const animatedProps2 = useAnimatedProps(() => ({
    cy: 12 - progress2.value * jumpHeight,
  }));
  const animatedProps3 = useAnimatedProps(() => ({
    cy: 12 - progress3.value * jumpHeight,
  }));

  return (
    <View style={[styles.container, style]}>
      <Svg width={(dotRadius * 2 + dotSpacing) * 3} height={24}>
        <AnimatedCircle
          cx={dotRadius}
          cy={12}
          r={dotRadius}
          fill={dotColor}
          animatedProps={animatedProps1}
        />
        <AnimatedCircle
          cx={dotRadius + dotSpacing + dotRadius * 2}
          cy={12}
          r={dotRadius}
          fill={dotColor}
          animatedProps={animatedProps2}
        />
        <AnimatedCircle
          cx={dotRadius + (dotSpacing + dotRadius * 2) * 2}
          cy={12}
          r={dotRadius}
          fill={dotColor}
          animatedProps={animatedProps3}
        />
      </Svg>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    height: 40,
    justifyContent: "center",
    alignItems: "center",
  },
});
```

#### OrbitingDots.Indicator.tsx

```tsx
// SpinnerSegments.tsx
import React, { useEffect } from "react";
import { StyleSheet, View, ViewStyle } from "react-native";
import Svg, { Circle } from "react-native-svg";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  useAnimatedProps,
  withTiming,
  withRepeat,
  withSequence,
  Easing,
} from "react-native-reanimated";

const AnimatedView = Animated.createAnimatedComponent(View);
const AnimatedCircle = Animated.createAnimatedComponent(Circle);

export interface OrbitDotLoaderProps {
  dotColor?: string;
  dotRadius?: number;
  centerRadius?: number;
  size?: number;
  duration?: number;
  numDots?: number;
  style?: ViewStyle;
}

export const OrbitDotLoader: React.FC<OrbitDotLoaderProps> = ({
  dotColor = "#fff",
  dotRadius = 4,
  centerRadius = 5,
  size = 40,
  duration = 900,
  numDots = 4,
  style,
}) => {
  const rotation = useSharedValue(0);
  const centerScale = useSharedValue(1);

  useEffect(() => {
    rotation.value = withRepeat(
      withTiming(360, {
        duration,
        easing: Easing.linear,
      }),
      -1,
    );
  }, [duration]);

  useEffect(() => {
    centerScale.value = withRepeat(
      withSequence(
        withTiming(1.3, { duration: 400, easing: Easing.out(Easing.ease) }),
        withTiming(1, { duration: 400, easing: Easing.in(Easing.ease) }),
      ),
      -1,
    );
  }, []);

  const rotateStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }],
  }));

  const centerProps = useAnimatedProps(() => ({
    r: centerRadius * centerScale.value,
  }));

  const center = size / 2;
  const orbitY = center - size * 0.3;

  return (
    <View style={[styles.container, { width: size, height: size }, style]}>
      <Svg width={size} height={size}>
        {/* Pulsing center circle */}
        <AnimatedCircle
          cx={center}
          cy={center}
          r={centerRadius}
          fill={dotColor}
          animatedProps={centerProps}
        />
      </Svg>

      {/* Rotating orbiting dots */}
      <AnimatedView style={[styles.spinner, rotateStyle]}>
        <Svg width={size} height={size}>
          {Array.from({ length: numDots }).map((_, i) => {
            const angle = (360 / numDots) * i;
            return (
              <Circle
                key={i}
                cx={center}
                cy={orbitY}
                r={dotRadius}
                fill={dotColor}
                transform={`rotate(${angle}, ${center}, ${center})`}
              />
            );
          })}
        </Svg>
      </AnimatedView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    justifyContent: "center",
    alignItems: "center",
  },
  spinner: {
    position: "absolute",
    justifyContent: "center",
    alignItems: "center",
  },
});
```

#### PlusingDots.Indicator.tsx

```tsx
// PulsingDots.tsx
import React, { useEffect } from "react";
import { View, StyleSheet } from "react-native";
import Svg, { Circle, Defs, LinearGradient, Stop } from "react-native-svg";
import Animated, {
  useSharedValue,
  useAnimatedProps,
  withRepeat,
  withTiming,
  Easing,
} from "react-native-reanimated";
import type { PulsingDotsProps } from "./PlusingDots.types";

const AnimatedCircle = Animated.createAnimatedComponent(Circle);
export const PulsingDots: React.FC<PulsingDotsProps> = ({
  dotCount = 3,
  radius = 6,
  spacing = 25,
  duration = 800,
  color = "#00C896",
  gradient,
}): React.ReactNode & React.JSX.Element => {
  const opacities = Array.from({ length: dotCount }, () => useSharedValue(0.3));

  useEffect(() => {
    opacities.forEach((opacity, i) => {
      setTimeout(() => {
        opacity.value = withRepeat(
          withTiming(1, {
            duration,
            easing: Easing.inOut(Easing.ease),
          }),
          -1,
          true
        );
      }, i * 200);
    });
  }, []);

  const animatedProps = opacities.map((val) =>
    useAnimatedProps(() => ({ opacity: val.value }))
  );

  const totalWidth = radius * 2 + (dotCount - 1) * spacing;

  return (
    <View style={styles.container}>
      <Svg width={totalWidth} height={radius * 3}>
        <Defs>
          {gradient?.map((g, i) => (
            <LinearGradient
              key={i}
              id={`grad-${i}`}
              x1="0"
              y1="0"
              x2="1"
              y2="1"
            >
              <Stop offset="0%" stopColor={g.from} />
              <Stop offset="100%" stopColor={g.to} />
            </LinearGradient>
          ))}
        </Defs>

        {animatedProps.map((props, i) => {
          const gradientId = gradient?.[i]
            ? `url(#grad-${i})`
            : gradient?.[0]
              ? `url(#grad-0)`
              : color;

          return (
            <AnimatedCircle
              key={i}
              cx={radius + i * spacing}
              cy={radius * 1.5}
              r={radius}
              fill={gradientId}
              animatedProps={props}
            />
          );
        })}
      </Svg>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    height: 40,
    justifyContent: "center",
    alignItems: "center",
  },
});
```

#### SpinnerArc.Indicator.tsx

```tsx
import React from "react";
import Svg, { Circle, Defs, LinearGradient, Stop } from "react-native-svg";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  Easing,
} from "react-native-reanimated";
import { View, StyleSheet } from "react-native";

const AnimatedView = Animated.createAnimatedComponent(View);

interface SpinnerArcProps {
  size?: number;
  colorStart?: string;
  colorEnd?: string;
  strokeWidth?: number;
  speed?: number;
  backgroundColor?: string;
  arcLength?: number; // Customizable arc length (stroke dash array)
}

export const SpinnerArc: React.FC<SpinnerArcProps> = ({
  size = 40,
  colorStart = "#FF4E4E",
  colorEnd = "#FF7A00",
  strokeWidth = 4,
  speed = 1000,
  backgroundColor = "#ddd",
  arcLength = 90,
}) => {
  const rotation = useSharedValue(0);

  // Rotation animation for spinner
  rotation.value = withRepeat(
    withTiming(360, {
      duration: speed,
      easing: Easing.linear,
    }),
    -1
  );

  // Animated style for rotating the arc
  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }],
  }));

  return (
    <AnimatedView
      style={[styles.loader, { width: size, height: size }, animatedStyle]}
    >
      <Svg width={size} height={size}>
        {/* Background Circle */}
        <Circle
          cx={size / 2}
          cy={size / 2}
          r={size / 2 - strokeWidth}
          stroke={backgroundColor}
          strokeWidth={strokeWidth}
          fill="none"
        />

        {/* Arc with Gradient */}
        <Defs>
          <LinearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <Stop offset="0%" stopColor={colorStart} />
            <Stop offset="100%" stopColor={colorEnd} />
          </LinearGradient>
        </Defs>

        <Circle
          cx={size / 2}
          cy={size / 2}
          r={size / 2 - strokeWidth}
          stroke="url(#gradient)"
          strokeWidth={strokeWidth}
          strokeDasharray={arcLength}
          strokeLinecap="round"
          fill="none"
        />
      </Svg>
    </AnimatedView>
  );
};

const styles = StyleSheet.create({
  loader: {
    justifyContent: "center",
    alignItems: "center",
  },
});
```

#### SegmentSpinner.Indicator.tsx

```tsx
import React, { useEffect } from "react";
import { StyleSheet, View } from "react-native";
import Svg, { Circle } from "react-native-svg";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  useAnimatedProps,
  withTiming,
  withRepeat,
  withSequence,
  Easing,
} from "react-native-reanimated";
import type { SpinnerSegmentsProps } from "./SegmentSpinner.types";

// Animated components
const AnimatedView = Animated.createAnimatedComponent(View);
const AnimatedCircle = Animated.createAnimatedComponent(Circle);

export const SpinnerSegments: React.FC<SpinnerSegmentsProps> = ({
  size = 40,
  color = "#fff",
  segmentColor = "#fff",
  centerColor = "#fff",
  speed = 900,
  segmentCount = 4,
  pulseSize = 1.3,
}) => {
  const rotation = useSharedValue(0);
  const centerScale = useSharedValue(1);

  // Rotation animation
  useEffect(() => {
    rotation.value = withRepeat(
      withTiming(360, {
        duration: speed,
        easing: Easing.linear,
      }),
      -1
    );
  }, [speed]);

  // Center pulse animation
  useEffect(() => {
    centerScale.value = withRepeat(
      withSequence(
        withTiming(pulseSize, {
          duration: 400,
          easing: Easing.out(Easing.ease),
        }),
        withTiming(1, { duration: 400, easing: Easing.in(Easing.ease) })
      ),
      -1
    );
  }, [pulseSize]);

  const rotateStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }],
  }));

  const centerProps = useAnimatedProps(() => ({
    r: 5 * centerScale.value,
  }));

  const segmentArray = Array.from({ length: segmentCount });

  return (
    <View style={[styles.container, { width: size, height: size }]}>
      <Svg width={size} height={size}>
        {/* Pulsing center circle */}
        <AnimatedCircle
          cx={size / 2}
          cy={size / 2}
          r={5}
          fill={centerColor}
          animatedProps={centerProps}
        />
      </Svg>

      {/* Rotating segments */}
      <AnimatedView style={[styles.spinner, rotateStyle]}>
        <Svg width={size} height={size}>
          {segmentArray.map((_, i) => {
            const angle = (360 / segmentCount) * i;
            return (
              <Circle
                key={i}
                cx={size / 2}
                cy={size / 8}
                r={4}
                fill={segmentColor}
                transform={`rotate(${angle}, ${size / 2}, ${size / 2})`}
              />
            );
          })}
        </Svg>
      </AnimatedView>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    justifyContent: "center",
    alignItems: "center",
  },
  spinner: {
    position: "absolute",
    justifyContent: "center",
    alignItems: "center",
  },
});
```

#### RotateSquare.Indicator.tsx

```tsx
import React, { useEffect } from "react";
import { View, StyleSheet, ViewStyle } from "react-native";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  Easing,
} from "react-native-reanimated";
import Svg, { Rect } from "react-native-svg";

const AnimatedSvg = Animated.createAnimatedComponent(Svg);

interface RotatingSquaresSpinnerProps {
  color?: string;
  squareSize?: number;
  spacing?: number;
  size?: number;
  duration?: number;
  repeatCount?: number;
  style?: ViewStyle;
}

export const RotatingSquaresSpinner: React.FC<RotatingSquaresSpinnerProps> = ({
  color = "#FF5722",
  squareSize = 10,
  spacing = 20,
  size = 60,
  duration = 1000,
  repeatCount = -1,
  style,
}) => {
  const rotation = useSharedValue<number>(0);

  useEffect(() => {
    rotation.value = withRepeat(
      withTiming(360, {
        duration,
        easing: Easing.linear,
      }),
      repeatCount,
    );
  }, [duration, repeatCount]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotation.value}deg` }],
  }));

  const half = size / 2;
  const offset = squareSize / 2;

  return (
    <View style={[styles.container, style]}>
      <AnimatedSvg width={size} height={size} style={animatedStyle}>
        <Rect
          x={half - spacing - offset}
          y={half - spacing - offset}
          width={squareSize}
          height={squareSize}
          fill={color}
        />
        <Rect
          x={half + spacing - offset}
          y={half - spacing - offset}
          width={squareSize}
          height={squareSize}
          fill={color}
        />
        <Rect
          x={half - spacing - offset}
          y={half + spacing - offset}
          width={squareSize}
          height={squareSize}
          fill={color}
        />
        <Rect
          x={half + spacing - offset}
          y={half + spacing - offset}
          width={squareSize}
          height={squareSize}
          fill={color}
        />
      </AnimatedSvg>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    justifyContent: "center",
    alignItems: "center",
  },
});
```

#### Pagination.tsx

```tsx
import React, { useEffect } from "react";
import {
  Dimensions,
  StyleProp,
  StyleSheet,
  View,
  ViewProps,
  ViewStyle,
} from "react-native";
import Animated, {
  useDerivedValue,
  withTiming,
  Easing,
  SharedValue,
  useAnimatedStyle,
  interpolateColor,
  interpolate,
  Extrapolation,
  useSharedValue,
  runOnJS,
} from "react-native-reanimated";
import {
  GestureDetector,
  Gesture,
  PanGesture,
} from "react-native-gesture-handler";
import { PaginationProps } from "./Pagination.types";

const ACTIVE_COLOR: string = "#c4c4c4";
const INACTIVE_COLOR: string = "#363636";
const CURRENT_COLOR: string = `#b724d4`;
const DOT_SIZE: number = 10;
const BORDER_RADIUS: number = 100;
const DOT_CONTAINER = 24;
const INITIAL_CONTAINER_STYLE: ViewStyle = {
  backgroundColor: "#9a3df2",
};
const { width } = Dimensions.get("window");

export function Pagination<T extends PaginationProps>(
  props: T & ViewProps
): React.ReactElement {
  const {
    activeIndex,
    totalItems,
    dotSize = props.dotSize ?? DOT_SIZE,
    inactiveColor = props.inactiveColor ?? INACTIVE_COLOR,
    activeColor = props.activeColor ?? ACTIVE_COLOR,
    currentColor = props.currentColor ?? CURRENT_COLOR,
    borderRadius: borderRadius = props.borderRadius ?? BORDER_RADIUS,
    dotContainer: dotContainer = props.dotContainer ?? DOT_CONTAINER,
    onIndexChange,
    containerStyle = props.containerStyle ?? INITIAL_CONTAINER_STYLE,
  } = props;

  const clampedActiveIndex = Math.min(Math.max(activeIndex, 0), totalItems - 1);

  const scale = useSharedValue<number>(1);
  const index_ = useSharedValue<number>(clampedActiveIndex);

  useEffect(() => {
    const _shapedIndex = (index_.value = Math.min(
      Math.max(activeIndex, 0),
      totalItems - 1
    ));
    if (onIndexChange) {
      onIndexChange(_shapedIndex);
    }
  }, [activeIndex, totalItems]);

  const longPressGesture: PanGesture = Gesture.Pan()
    .onStart(() => {
      scale.value = withTiming<number>(1.2, { duration: 150 });
    })
    .onUpdate((e) => {
      const index = Math.floor(e.absoluteX / (width / totalItems));
      if (index >= 0 && index < totalItems) {
        index_.value = index;
        if (onIndexChange) {
          runOnJS(onIndexChange)(index);
        }
      }
    })
    .onEnd(() => {
      scale.value = withTiming<number>(1, { duration: 150 });
    })
    .onFinalize(() => {
      scale.value = withTiming<number>(1, { duration: 150 });
    });

  const animatedStyle = useAnimatedStyle<ViewStyle>(() => {
    return {
      transform: [{ scale: scale.value }],
    };
  });

  const animation = useDerivedValue<number>(() => {
    return withTiming<number>(index_.value, {
      easing: Easing.linear,
      duration: 300,
    });
  });

  return (
    <GestureDetector gesture={longPressGesture}>
      <Animated.View style={[animatedStyle]} {...props}>
        <View style={{ flexDirection: "row" }}>
          <Indicator
            animation={animation}
            dotContainer={dotContainer}
            containerStyle={containerStyle as StyleProp<ViewStyle>}
            radius={borderRadius}
          />
          {[...Array(totalItems).keys()].map((index) => (
            <Dot
              key={`index-${index}`}
              index={index}
              animation={animation}
              activeColor={activeColor}
              inactiveColor={inactiveColor}
              currentColor={currentColor}
              dotSize={dotSize}
              borderRadius={borderRadius}
              dotContainer={dotContainer}
            />
          ))}
        </View>
      </Animated.View>
    </GestureDetector>
  );
}

function Indicator({
  animation,
  dotContainer,
  radius,
  containerStyle,
}: {
  animation: SharedValue<number>;
  dotContainer?: number;
  radius?: number;
  containerStyle?: StyleProp<ViewStyle>;
}) {
  const indicatorAnimatedStyle = useAnimatedStyle(() => {
    const width = DOT_CONTAINER + DOT_CONTAINER * animation.value;
    const opacity = interpolate(
      animation.value,
      [0, 0.01],
      [0, 1],
      Extrapolation.CLAMP
    );

    return {
      width,
      opacity: withTiming<number>(opacity, {
        duration: 200,
        easing: Easing.linear,
      }),
    };
  });

  return (
    <Animated.View
      style={[
        {
          height: dotContainer,
          position: "absolute",
          left: 0,
          top: 0,
          borderRadius: radius,
        },
        containerStyle,
        indicatorAnimatedStyle,
      ]}
    />
  );
}

function Dot<T extends {}>({
  index,
  animation,
  inactiveColor = INACTIVE_COLOR,
  activeColor = ACTIVE_COLOR,
  currentColor = CURRENT_COLOR,
  dotSize = DOT_SIZE,
  borderRadius = BORDER_RADIUS,
}: {
  index: number;
  animation: SharedValue<number>;
  inactiveColor?: string;
  activeColor?: string;
  currentColor?: string;
  dotSize?: number;
  borderRadius?: number;
  dotContainer?: number;
}) {
  const animatedDotContainerStyle = useAnimatedStyle(() => {
    return {
      backgroundColor: interpolateColor(
        animation.value,
        [index - 1, index, index + 1],
        [inactiveColor, activeColor, currentColor]
      ),
    };
  });

  return (
    <Animated.View style={styles.dotContainer}>
      <Animated.View
        style={[
          styles.dot,
          {
            width: dotSize,
            height: dotSize,
            borderRadius: borderRadius,
          },
          animatedDotContainerStyle,
        ]}
      />
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  dotContainer: {
    width: DOT_CONTAINER,
    height: DOT_CONTAINER,
    justifyContent: "center",
    alignItems: "center",
  },
  container: {
    flexDirection: "row",
    justifyContent: "center",
    alignItems: "center",
  },
  dot: {
    width: 20,
    height: 10,

    backgroundColor: "#000",
    marginHorizontal: 5,
  },
});
```

#### SeekBar.tsx

```tsx
import React from "react";
import { View, StyleSheet } from "react-native";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  useAnimatedGestureHandler,
  runOnJS,
  withSpring,
  withSequence,
  withTiming,
  Easing,
} from "react-native-reanimated";
import {
  PanGestureHandler,
  PanGestureHandlerGestureEvent,
  TapGestureHandler,
  TapGestureHandlerGestureEvent,
} from "react-native-gesture-handler";
import type { SeekBarProps } from "./SeekBar.types";

export const SeekBar: React.FC<SeekBarProps> = ({
  value,
  onValueChange,
  width = 300,
  height = 2,
  activeHeight = 4,
  activeColor = "#FFFFFF",
  inactiveColor = "rgba(255, 255, 255, 0.3)",
  disabled = false,
  tapToSeek = true,
}) => {
  const initialValue = Math.max(0, Math.min(1, value));
  const progress = useSharedValue(initialValue);
  const isActive = useSharedValue(false);
  const trackScale = useSharedValue(1);

  const customEasing = Easing.bezier(0.25, 0.1, 0.25, 1);

  React.useEffect(() => {
    const clampedValue = Math.max(0, Math.min(1, value));
    if (!isActive.value) {
      progress.value = withTiming(clampedValue, {
        duration: 300,
        easing: customEasing,
      });
    }
  }, [value]);

  const panGestureHandler = useAnimatedGestureHandler<
    PanGestureHandlerGestureEvent,
    { startProgress: number }
  >({
    onStart: (_, context) => {
      if (disabled) return;
      context.startProgress = progress.value;
      isActive.value = true;
      trackScale.value = withTiming(activeHeight / height, {
        duration: 200,
        easing: customEasing,
      });
    },
    onActive: (event, context) => {
      if (disabled) return;

      const progressDelta = event.translationX / width;
      const newProgress = Math.max(
        0,
        Math.min(1, context.startProgress + progressDelta),
      );

      progress.value = newProgress;
      runOnJS(onValueChange)(newProgress);
    },
    onFinish: () => {
      if (disabled) return;
      isActive.value = false;
      trackScale.value = withTiming(1, {
        duration: 200,
        easing: customEasing,
      });
    },
  });

  const tapGestureHandler =
    useAnimatedGestureHandler<TapGestureHandlerGestureEvent>({
      onStart: (event) => {
        if (disabled || !tapToSeek) return;

        const newProgress = Math.max(0, Math.min(1, event.x / width));
        progress.value = withTiming(newProgress, {
          duration: 300,
          easing: customEasing,
        });

        trackScale.value = withSequence(
          withTiming(activeHeight / height, {
            duration: 200,
            easing: customEasing,
          }),
          withTiming(1, {
            duration: 200,
            easing: customEasing,
          }),
        );

        runOnJS(onValueChange)(newProgress);
      },
    });

  const containerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ scaleY: trackScale.value }],
      borderRadius: 100,
    };
  });

  const activeTrackAnimatedStyle = useAnimatedStyle(() => {
    const progressWidth = Math.max(0, Math.min(width, progress.value * width));
    return {
      width: progressWidth,
      borderRadius: 99,
    };
  });

  return (
    <View style={[styles.wrapper, { width, height: activeHeight }]}>
      <TapGestureHandler onGestureEvent={tapGestureHandler}>
        <Animated.View>
          <PanGestureHandler onGestureEvent={panGestureHandler}>
            <Animated.View
              style={[
                styles.container,
                {
                  width,
                  height,
                },
                containerAnimatedStyle,
              ]}
            >
              <View
                style={[
                  styles.track,
                  {
                    width,
                    height,
                    backgroundColor: inactiveColor,
                  },
                ]}
              />

              <Animated.View
                style={[
                  styles.activeTrack,
                  {
                    height,
                    backgroundColor: activeColor,
                  },
                  activeTrackAnimatedStyle,
                ]}
              />
            </Animated.View>
          </PanGestureHandler>
        </Animated.View>
      </TapGestureHandler>
    </View>
  );
};

const styles = StyleSheet.create({
  wrapper: {
    justifyContent: "center",
    alignItems: "center",
  },
  container: {
    justifyContent: "center",
    alignItems: "flex-start",
  },
  track: {
    borderRadius: 90,
  },
  activeTrack: {
    borderRadius: 200,
    position: "absolute",
  },
});

export default SeekBar;
```

#### Shimmer.tsx

```tsx
import { LinearGradient } from "expo-linear-gradient";
import React, { useCallback, useEffect, useState } from "react";
import { View, LayoutChangeEvent, LayoutRectangle } from "react-native";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withSequence,
  withTiming,
  Easing,
  cancelAnimation,
} from "react-native-reanimated";
import type { ShimmerEffectProps } from "./Shimmer.types";

/**
 * @returns {React.ReactNode | React.JSX.Element}
 */
export const ShimmerEffect: React.FC<ShimmerEffectProps> = ({
  isLoading = true,

  shimmerColors = [
    "rgba(15, 15, 15, 0.1)",
    "rgba(255, 255, 255, 0.15)",
    "rgba(15, 15, 15, 0.1)",
  ],
  duration = 1200,
  className,

  style,
  variant = "shimmer",
  direction = "leftToRight",
}) => {
  const [layout, setLayout] = useState<LayoutRectangle | null>(null);
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const opacity = useSharedValue(0.5);

  const onLayout = useCallback((e: LayoutChangeEvent) => {
    setLayout(e.nativeEvent.layout);
  }, []);

  const shimmerStyle = useAnimatedStyle(() => {
    const transforms = [];

    if (variant === "shimmer") {
      if (direction === "leftToRight" || direction === "rightToLeft") {
        transforms.push({ translateX: translateX.value });
      } else {
        transforms.push({ translateY: translateY.value });
      }
    }

    return {
      transform: transforms,
      opacity: opacity.value,
    };
  });

  useEffect(() => {
    if (!layout || !isLoading) {
      cancelAnimation(translateX);
      cancelAnimation(translateY);
      cancelAnimation(opacity);
      return;
    }

    if (variant === "shimmer") {
      switch (direction) {
        case "leftToRight":
          translateX.value = -layout.width - 350;
          translateX.value = withRepeat(
            withTiming(layout.width, {
              duration,
              easing: Easing.linear,
            }),
            -1,
            false,
          );
          break;

        case "rightToLeft":
          translateX.value = layout.width + 350;
          translateX.value = withRepeat(
            withTiming(-layout.width - 350, {
              duration,
              easing: Easing.linear,
            }),
            -1,
            false,
          );
          break;

        case "topToBottom":
          translateY.value = -layout.height - 250;
          translateY.value = withRepeat(
            withTiming(layout.height, {
              duration,
              easing: Easing.linear,
            }),
            -1,
            false,
          );
          break;

        case "bottomToTop":
          translateY.value = layout.height + 100;
          translateY.value = withRepeat(
            withTiming(-layout.height - 100, {
              duration,
              easing: Easing.linear,
            }),
            -1,
            false,
          );
          break;
      }
      opacity.value = 1;
    } else {
      opacity.value = withRepeat(
        withSequence(
          withTiming(1, { duration: duration / 2 }),
          withTiming(0.3, { duration: duration / 2 }),
        ),
        -1,
        true,
      );
    }

    return () => {
      cancelAnimation(translateX);
      cancelAnimation(translateY);
      cancelAnimation(opacity);
    };
  }, [layout, isLoading, duration, variant, direction]);

  return (
    <View
      onLayout={onLayout}
      className={className}
      style={[style, { overflow: "hidden" }]}
    >
      {isLoading && layout && (
        <Animated.View
          pointerEvents="none"
          style={[
            {
              position: "absolute",
              top: 0,
              left: 0,
              width:
                variant === "shimmer" &&
                (direction === "leftToRight" || direction === "rightToLeft")
                  ? layout.width * 3
                  : layout.width,
              height:
                variant === "shimmer" &&
                (direction === "topToBottom" || direction === "bottomToTop")
                  ? layout.height * 3
                  : layout.height,
            },
            shimmerStyle,
          ]}
        >
          {variant === "shimmer" ? (
            <LinearGradient
              colors={shimmerColors as [string, string, ...string[]]}
              start={
                direction === "leftToRight" || direction === "rightToLeft"
                  ? { x: 0, y: 0.5 }
                  : { x: 0.5, y: 0 }
              }
              end={
                direction === "leftToRight" || direction === "rightToLeft"
                  ? { x: 1, y: 0.5 }
                  : { x: 0.5, y: 1 }
              }
              style={{ flex: 1 }}
            />
          ) : (
            <View
              style={{
                flex: 1,
                backgroundColor: shimmerColors[0],
              }}
            />
          )}
        </Animated.View>
      )}
    </View>
  );
};
```

#### Steppper.tsx

```tsx
import React, { useMemo } from "react";
import { StyleSheet } from "react-native";
import { StepperContext } from "./context/StepperContext";

import Animated, { LinearTransition } from "react-native-reanimated";
import type { StepperProps } from "./Stepper.types";

export const Stepper: React.FC<StepperProps> = ({
  children,
  value: controlledValue,
  onChange: controlledOnChange,
  defaultValue = 0,
  min = 0,
  max = Infinity,
  step = 1,
  disabled = false,
  variant = "light",
  style,
  containerStyle,
}: StepperProps): React.ReactNode => {
  const [internalValue, setInternalValue] = React.useState(defaultValue);

  const isControlled = controlledValue !== undefined;
  const value = isControlled ? controlledValue : internalValue;

  const handleChange = (newValue: number) => {
    const clampedValue = Math.min(Math.max(newValue, min), max);

    if (!isControlled) {
      setInternalValue(clampedValue);
    }

    controlledOnChange?.(clampedValue);
  };

  const contextValue = useMemo(
    () => ({
      value,
      onChange: handleChange,
      min,
      max,
      step,
      disabled,
      variant,
    }),
    [value, handleChange, min, max, step, disabled, variant]
  );

  return (
    <StepperContext.Provider value={contextValue}>
      <Animated.View
        style={[styles.container, containerStyle]}
        layout={LinearTransition.springify().damping(14).stiffness(100)}
      >
        <Animated.View
          layout={LinearTransition.springify().damping(14).stiffness(100)}
          style={[styles.stepper, style, variant === "dark" && styles.darkMode]}
        >
          {children}
        </Animated.View>
      </Animated.View>
    </StepperContext.Provider>
  );
};

const styles = StyleSheet.create({
  container: {
    alignItems: "center",
    justifyContent: "center",
  },
  stepper: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    borderRadius: 28,
    borderWidth: 1,
    borderColor: "rgba(0, 0, 0, 0.1)",
    overflow: "hidden",
    paddingHorizontal: 4,
    paddingVertical: 4,
  },
  darkMode: {
    backgroundColor: "#121212",
    borderColor: "rgba(255, 255, 255, 0.1)",
  },
});
```

#### TimelineView.tsx

```tsx
import React, { useEffect } from "react";
import { View, Text, StyleSheet, TouchableOpacity } from "react-native";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  withSequence,
  FadeInDown,
  LinearTransition,
  interpolateColor,
} from "react-native-reanimated";
import { Feather } from "@expo/vector-icons";
import type { TimelineProps } from "./TimelineView.types";

const AnimatedTouchableOpacity =
  Animated.createAnimatedComponent(TouchableOpacity);
const AnimatedFeather = Animated.createAnimatedComponent(Feather);

export const Timeline: React.FC<TimelineProps> &
  React.FunctionComponent<TimelineProps> = ({
  items = [],
  activeColor = "#6366f1",
  inactiveColor = "#cbd5e1",
  animated = true,
  animationType = "bounce",
  onItemPress,
  containerStyle,
  titleStyle,
  descriptionStyle,
  timestampStyle,
  lineWidth = 2,
  iconSize = 20,
  metaContainerStyle,
  metaTextStyle,
}: TimelineProps): React.ReactNode & React.JSX.Element => {
  const statusRefs = React.useRef<Record<string | number, string>>({});

  useEffect(() => {
    items.forEach((item) => {
      statusRefs.current[item.id] = item.status || "upcoming";
    });

    return () => {
      statusRefs.current = {};
    };
  }, []);

  if (!items || items.length === 0) {
    return null as unknown as React.ReactNode & React.JSX.Element;
  }

  return (
    <Animated.View style={[styles.container, containerStyle]}>
      {items.map((item, index) => {
        const isFirst = index === 0;
        const isLast = index === items.length - 1;
        const isComplete = item.status === "complete";
        const isCurrent = item.status === "current";
        const isUpcoming = item.status === "upcoming" || !item.status;

        const prevStatus = statusRefs.current[item.id];
        const wasComplete = prevStatus === "complete";
        const statusChanged = prevStatus && prevStatus !== item.status;
        statusRefs.current[item.id] = item.status || "upcoming";

        const dotScale = useSharedValue(statusChanged ? 1.5 : 1);
        const dotColorAnimated = useSharedValue(
          isComplete ? 1 : isCurrent ? 0.5 : 0,
        );
        const lineProgress = useSharedValue(isComplete ? 1 : 0);
        const iconRotate = useSharedValue(statusChanged ? 0 : 1);

        useEffect(() => {
          if (statusChanged) {
            switch (animationType) {
              case "bounce":
                dotScale.value = withSequence(
                  withTiming(1.5, { duration: 200 }),
                  withSpring(1),
                );
                break;
              case "spring":
                dotScale.value = withSpring(1.2, { damping: 2, stiffness: 80 });
                break;
              case "rotate":
                iconRotate.value = withSequence(
                  withTiming(0, { duration: 10 }),
                  withTiming(4, { duration: 800 }),
                );
                dotScale.value = withSequence(
                  withTiming(1.6, { duration: 200 }),
                  withSpring(1),
                );
                dotColorAnimated.value = withSequence(
                  withTiming(0, { duration: 200 }),
                  withTiming(isComplete ? 1 : isCurrent ? 0.5 : 0, {
                    duration: 400,
                  }),
                );
                break;
              case "fade":
                dotColorAnimated.value = withSequence(
                  withTiming(0, { duration: 200 }),
                  withTiming(isComplete ? 1 : isCurrent ? 0.5 : 0, {
                    duration: 400,
                  }),
                );
                break;
              case "scale":
                dotScale.value = withSequence(
                  withTiming(0.5, { duration: 200 }),
                  withTiming(1.2, { duration: 200 }),
                  withTiming(1, { duration: 200 }),
                );
                break;
              default:
                dotScale.value = withSequence(
                  withTiming(1.5, { duration: 200 }),
                  withSpring(1),
                );
            }

            dotColorAnimated.value = withTiming(
              isComplete ? 1 : isCurrent ? 0.5 : 0,
              { duration: 400 },
            );

            iconRotate.value = withSequence(
              withTiming(0, { duration: 10 }),
              withTiming(1, { duration: 400 }),
            );

            if (isComplete) {
              lineProgress.value = withTiming(1, { duration: 600 });
            } else if (wasComplete) {
              lineProgress.value = withTiming(0, { duration: 600 });
            }
          } else {
            lineProgress.value = isComplete ? 1 : 0;
          }
        }, [item.status, isComplete, isCurrent, animationType]);

        const dotAnimatedStyle = useAnimatedStyle(() => {
          return {
            transform: [{ scale: dotScale.value }],
            backgroundColor: interpolateColor(
              dotColorAnimated.value,
              [0, 0.5, 1],
              [inactiveColor, activeColor, activeColor],
            ),
          };
        });

        const lineAnimatedStyle = useAnimatedStyle(() => {
          return {
            backgroundColor: interpolateColor(
              lineProgress.value,
              [0, 1],
              [inactiveColor, activeColor],
            ),
            width: lineWidth,
            transform: [
              { scaleY: lineProgress.value },
              { translateY: -2 * (1 - lineProgress.value) },
            ],
            opacity: 0.6 + lineProgress.value * 0.4,
          };
        });

        const iconAnimatedStyle = useAnimatedStyle(() => {
          return {
            transform: [
              { rotateZ: `${iconRotate.value * 360}deg` },
              { scale: 0.8 + iconRotate.value * 0.2 },
            ],
          };
        });

        const iconName =
          item.icon ||
          (isComplete ? "check" : isCurrent ? "activity" : "circle");

        const textColor = isComplete || isCurrent ? "#0f172a" : "#64748b";

        return (
          <AnimatedTouchableOpacity
            key={item.id}
            style={styles.itemContainer}
            activeOpacity={onItemPress ? 0.7 : 1}
            onPress={() => onItemPress && onItemPress(item)}
            entering={
              animated ? FadeInDown.delay(index * 100).springify() : undefined
            }
            layout={LinearTransition.springify()}
          >
            <View style={styles.timelineColumn}>
              <Animated.View style={[styles.dot, dotAnimatedStyle]}>
                <Animated.View style={[{}, iconAnimatedStyle]}>
                  <AnimatedFeather
                    name={iconName as any}
                    size={iconSize * 0.7}
                    color="#fff"
                  />
                </Animated.View>
              </Animated.View>

              {!isLast && (
                <Animated.View style={[styles.line, lineAnimatedStyle]} />
              )}
            </View>

            <View style={styles.contentColumn}>
              <View style={styles.itemHeader}>
                <Text style={[styles.title, { color: textColor }, titleStyle]}>
                  {item.title}
                </Text>

                {item.timestamp && (
                  <Text style={[styles.timestamp, timestampStyle]}>
                    {item.timestamp}
                  </Text>
                )}
              </View>

              {item.description && (
                <Text style={[styles.description, descriptionStyle]}>
                  {item.description}
                </Text>
              )}

              {item.meta && (
                <View style={[styles.metaContainer, metaContainerStyle]}>
                  <Text style={[styles.metaText, metaTextStyle]}>
                    {item.meta}
                  </Text>
                </View>
              )}

              {item.children && (
                <View
                  style={[styles.childrenContainer, item.childrenContainer]}
                >
                  {item.children}
                </View>
              )}
            </View>
          </AnimatedTouchableOpacity>
        );
      })}
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 16,
  },
  itemContainer: {
    flexDirection: "row",
    marginBottom: 24,
  },
  timelineColumn: {
    alignItems: "center",
    width: 40,
  },
  contentColumn: {
    flex: 1,
    marginLeft: 12,
    marginTop: -4,
  },
  dot: {
    width: 28,
    height: 28,
    borderRadius: 14,
    justifyContent: "center",
    alignItems: "center",
    elevation: 2,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 1,
  },
  line: {
    flex: 1,
    marginTop: 4,
  },
  itemHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "flex-start",
    marginBottom: 6,
  },
  title: {
    fontSize: 16,
    fontWeight: "600",
    flex: 1,
  },
  description: {
    fontSize: 14,
    color: "#64748b",
    lineHeight: 20,
    marginBottom: 8,
  },
  timestamp: {
    fontSize: 12,
    color: "#94a3b8",
    marginLeft: 8,
  },
  metaContainer: {
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 6,
    alignSelf: "flex-start",
    marginTop: 4,
    marginBottom: 8,
  },
  metaText: {
    fontSize: 12,
    color: "#475569",
  },
  childrenContainer: {
    // marginTop: 12,
    // backgroundColor: "#f8fafc",
    // borderRadius: 8,
    padding: 12,
  },
});
```

#### Toast.tsx

```tsx
import React, { useEffect, useRef } from "react";
import {
  StyleSheet,
  View,
  Text,
  TouchableOpacity,
  Pressable,
  LayoutAnimation,
  Platform,
  UIManager,
} from "react-native";
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withTiming,
  withSpring,
  Easing,
  interpolate,
  runOnJS,
  Layout,
} from "react-native-reanimated";
import type {
  Toast as ToastType,
  ToastType as ToastVariant,
} from "./Toast.types";
import { useToast } from "./context/ToastContext";

// Enable LayoutAnimation for Android
if (Platform.OS === "android") {
  if (UIManager.setLayoutAnimationEnabledExperimental) {
    UIManager.setLayoutAnimationEnabledExperimental(true);
  }
}

interface ToastProps {
  toast: ToastType;
  index: number;
  onHeightChange?: (id: string, height: number) => void;
}

const getBackgroundColor = (type: ToastVariant) => {
  switch (type) {
    case "success":
      return "#10B981";
    case "error":
      return "#EF4444";
    case "warning":
      return "#F59E0B";
    case "info":
      return "#3B82F6";
    default:
      return "#262626";
  }
};

const getIconForType = (type: ToastVariant) => {
  switch (type) {
    case "success":
      return "‚úì";
    case "error":
      return "‚úó";
    case "warning":
      return "‚ö†";
    case "info":
      return "‚Ñπ";
    default:
      return "";
  }
};

export const Toast: React.FC<ToastProps> = ({ toast, index }) => {
  const prevContentRef = useRef<string | React.ReactNode | null>(null);
  const prevTypeRef = useRef<ToastVariant | null>(null);

  const { dismiss } = useToast();
  const opacity = useSharedValue(0);
  const translateY = useSharedValue(
    toast.options.position === "top" ? -20 : 20,
  );
  const scale = useSharedValue(0.95);
  const rotateZ = useSharedValue(toast.options.position === "top" ? -2 : 2);
  const height = useSharedValue(0);
  const viewRef = useRef<View>(null);

  // Calculate the offset based on index for stacking effect
  const getStackOffset = () => {
    const baseOffset = 8; // Base offset between toasts
    const maxOffset = 20; // Maximum offset
    const offset = Math.min(index * baseOffset, maxOffset);
    return toast.options.position === "top" ? -offset : offset;
  };

  const handleDismiss = () => {
    LayoutAnimation.configureNext({
      duration: 300,
      create: {
        type: LayoutAnimation.Types.easeInEaseOut,
        property: LayoutAnimation.Properties.opacity,
      },
      update: {
        type: LayoutAnimation.Types.easeInEaseOut,
      },
      delete: {
        type: LayoutAnimation.Types.easeInEaseOut,
        property: LayoutAnimation.Properties.opacity,
      },
    });
    dismiss(toast.id);
    toast.options.onClose?.();
  };

  useEffect(() => {
    // Stagger the entrance animation based on index
    const delay = index * 50;

    // Configure layout animation for height changes
    LayoutAnimation.configureNext({
      duration: 300,
      create: {
        type: LayoutAnimation.Types.easeInEaseOut,
        property: LayoutAnimation.Properties.opacity,
      },
      update: {
        type: LayoutAnimation.Types.easeInEaseOut,
      },
    });

    setTimeout(() => {
      opacity.value = withTiming(1, {
        duration: 300,
        easing: Easing.bezier(0.4, 0, 0.2, 1),
      });

      translateY.value = withSpring(getStackOffset(), {
        damping: 20,
        stiffness: 150,
        mass: 0.6,
        velocity: 0.5,
        restDisplacementThreshold: 0.01,
        restSpeedThreshold: 0.01,
      });

      scale.value = withSpring(1, {
        damping: 20,
        stiffness: 150,
        mass: 0.6,
      });

      rotateZ.value = withTiming(0, {
        duration: 300,
        easing: Easing.bezier(0.4, 0, 0.2, 1),
      });
    }, delay);

    if (toast.options.duration > 0) {
      const exitDelay = Math.max(0, toast.options.duration - 500);

      const exitAnimations = () => {
        opacity.value = withTiming(0, {
          duration: 250,
          easing: Easing.bezier(0.4, 0, 0.2, 1),
        });

        translateY.value = withTiming(
          toast.options.position === "top" ? -20 : 20,
          {
            duration: 250,
            easing: Easing.bezier(0.4, 0, 0.2, 1),
          },
        );

        scale.value = withTiming(0.95, {
          duration: 250,
          easing: Easing.bezier(0.4, 0, 0.2, 1),
        });

        setTimeout(() => {
          runOnJS(handleDismiss)();
        }, 250);
      };

      setTimeout(exitAnimations, exitDelay);
    }
  }, [toast, opacity, translateY, scale, rotateZ, index]);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      opacity: opacity.value,
      transform: [
        { translateY: translateY.value },
        { scale: scale.value },
        { rotateZ: `${rotateZ.value}deg` },
      ],
      zIndex: 1000 - index, // Higher index toasts appear behind
    };
  });

  const handlePress = () => {
    opacity.value = withTiming(0, {
      duration: 200,
      easing: Easing.bezier(0.4, 0, 0.2, 1),
    });

    translateY.value = withTiming(toast.options.position === "top" ? -20 : 20, {
      duration: 200,
      easing: Easing.bezier(0.4, 0, 0.2, 1),
    });

    scale.value = withTiming(0.95, {
      duration: 200,
      easing: Easing.bezier(0.4, 0, 0.2, 1),
    });

    setTimeout(() => {
      handleDismiss();
    }, 200);
  };

  const backgroundColor = getBackgroundColor(toast.options.type);
  const icon = getIconForType(toast.options.type);

  return (
    <Animated.View
      style={[
        styles.toastContainer,
        animatedStyle,
        {
          marginTop: index > 0 ? 8 : 0,
          marginBottom: index > 0 ? 0 : 8,
        },
      ]}
    >
      <Pressable
        style={[styles.toast, { backgroundColor }]}
        onPress={handlePress}
        android_ripple={{ color: "rgba(255, 255, 255, 0.1)" }}
      >
        {icon ? <Text style={styles.icon}>{icon}</Text> : null}
        <View style={styles.contentContainer}>
          {typeof toast.content === "string" ? (
            <Text style={styles.text}>{toast.content}</Text>
          ) : (
            toast.content
          )}
        </View>
        {toast.options.action && (
          <TouchableOpacity
            style={styles.actionButton}
            onPress={() => {
              toast.options.action?.onPress!();
              dismiss(toast.id);
            }}
          >
            <Text style={styles.actionText}>{toast.options.action.label}</Text>
          </TouchableOpacity>
        )}
      </Pressable>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  toastContainer: {
    width: "90%",
    maxWidth: 400,
    alignSelf: "center",
    marginVertical: 4,
    borderRadius: 12,
    overflow: "hidden",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 4,
    },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 8,
  },
  toast: {
    flexDirection: "row",
    alignItems: "center",
    padding: 16,
    borderRadius: 12,
  },
  icon: {
    color: "#fff",
    fontSize: 20,
    marginRight: 12,
    fontWeight: "bold",
    textAlign: "center",
    width: 24,
  },
  contentContainer: {
    flex: 1,
  },
  text: {
    color: "#fff",
    fontSize: 16,
    fontWeight: "500",
    lineHeight: 20,
  },
  actionButton: {
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 6,
    backgroundColor: "rgba(255, 255, 255, 0.2)",
    marginLeft: 12,
  },
  actionText: {
    color: "#fff",
    fontSize: 14,
    fontWeight: "600",
  },
});
```

#### ToastViewPort.tsx

```tsx
import React from "react";
import { View, StyleSheet } from "react-native";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useToast } from "./context/ToastContext";
import { Toast } from "./Toast";

export const ToastViewport: React.FC = () => {
  const { toasts } = useToast();
  const insets = useSafeAreaInsets();

  const topToasts = toasts.filter((toast) => toast.options.position === "top");
  const bottomToasts = toasts.filter(
    (toast) => toast.options.position === "bottom",
  );

  return (
    <>
      <View
        style={[
          styles.viewport,
          styles.topViewport,
          {
            paddingTop: insets.top + 10,
          },
        ]}
      >
        {topToasts.map((toast, index) => (
          <Toast key={toast.id} toast={toast} index={index} />
        ))}
      </View>
      <View
        style={[
          styles.viewport,
          styles.bottomViewport,
          {
            paddingBottom: insets.bottom + 10,
          },
        ]}
      >
        {bottomToasts.map((toast, index) => (
          <Toast key={toast.id} toast={toast} index={index} />
        ))}
      </View>
    </>
  );
};

const styles = StyleSheet.create({
  toastContainer: {
    width: "90%",
    maxWidth: 400,
    alignSelf: "center",
    marginVertical: 4,
    borderRadius: 8,
    overflow: "hidden",
    shadowColor: "#000",
    shadowOffset: {
      width: 0,
      height: 2,
    },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  toast: {
    flexDirection: "row",
    alignItems: "center",
    padding: 12,
  },
  icon: {
    color: "#fff",
    fontSize: 18,
    marginRight: 12,
    fontWeight: "bold",
  },
  contentContainer: {
    flex: 1,
  },
  text: {
    color: "#fff",
    fontSize: 16,
  },
  actionButton: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 4,
    backgroundColor: "rgba(255, 255, 255, 0.2)",
    marginLeft: 8,
  },
  actionText: {
    color: "#fff",
    fontSize: 14,
    fontWeight: "bold",
  },
  viewport: {
    position: "absolute",
    left: 0,
    right: 0,
    zIndex: 9999,
    paddingHorizontal: 16,
    pointerEvents: "box-none",
  },
  topViewport: {
    top: 0,
  },
  bottomViewport: {
    bottom: 0,
  },
});
```

#### ToastContext.tsx

```tsx
import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useState,
} from "react";
import type { Toast, ToastContextValue, ToastOptions } from "../Toast.types";

const DEFAULT_TOAST_OPTIONS: Required<ToastOptions> = {
  duration: 3000,
  type: "default",
  position: "bottom",
  onClose: () => {},
  action: {},
};

const ToastContext = createContext<ToastContextValue | undefined>(undefined);

export const useToast = (): ToastContextValue => {
  const context = useContext(ToastContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
};

export const ToastProvider: React.FC<{ children: React.ReactNode }> = ({
  children,
}) => {
  const [toasts, setToasts] = useState<Toast[]>([]);

  const show = useCallback(
    (content: React.ReactNode | string, options?: ToastOptions): string => {
      const id = Math.random().toString(36).substring(2, 9);
      const toast: Toast = {
        id,
        content,
        options: {
          ...DEFAULT_TOAST_OPTIONS,
          ...options,
        },
      };

      setToasts((prevToasts) => [...prevToasts, toast]);
      return id;
    },
    []
  );

  const update = useCallback(
    (id: string, content: React.ReactNode | string, options?: ToastOptions) => {
      setToasts((prevToasts) =>
        prevToasts.map((toast) =>
          toast.id === id
            ? {
                ...toast,
                content,
                options: {
                  ...toast.options,
                  ...options,
                },
              }
            : toast
        )
      );
    },
    []
  );

  const dismiss = useCallback((id: string) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  }, []);

  const dismissAll = useCallback(() => {
    setToasts([]);
  }, []);

  useEffect(() => {
    if (toasts.length === 0) return;

    const timeouts: NodeJS.Timeout[] = [];

    toasts.forEach((toast) => {
      if (toast.options.duration > 0) {
        const timeout = setTimeout(() => {
          dismiss(toast.id);
          toast.options.onClose?.();
        }, toast.options.duration);
        timeouts.push(timeout);
      }
    });

    return () => {
      timeouts.forEach(clearTimeout);
    };
  }, [toasts, dismiss]);

  const value: ToastContextValue = {
    toasts,
    show,
    update,
    dismiss,
    dismissAll,
  };

  return (
    <ToastContext.Provider value={value}>{children}</ToastContext.Provider>
  );
};
```

#### index.tsx

```tsx
import * as React from "react";
import { ToastProvider, useToast } from "./context/ToastContext";
import { ToastViewport } from "./ToastViewPort";
import type { ToastOptions, ToastProps } from "./Toast.types";
type ToastRef = {
  show?: (content: React.ReactNode | string, options?: ToastOptions) => string;
  update?: (
    id: string,
    content: React.ReactNode | string,
    options?: ToastOptions
  ) => void;
  dismiss?: (id: string) => void;
  dismissAll?: () => void;
};

const toastRef: ToastRef = {};

const ToastController: React.FC = () => {
  const toast = useToast();

  toastRef.show = toast.show;
  toastRef.update = toast.update;
  toastRef.dismiss = toast.dismiss;
  toastRef.dismissAll = toast.dismissAll;

  return null;
};

export const ToastProviderWithViewport: React.FC<ToastProps> = ({
  children,
}) => {
  return (
    <ToastProvider>
      <ToastController />
      {children}
      <ToastViewport />
    </ToastProvider>
  );
};

export const Toast = {
  show: (content: React.ReactNode | string, options?: ToastOptions): string => {
    if (!toastRef.show) {
      console.warn(
        "Toast provider not initialized. Make sure you have wrapped your app with ToastProviderWithViewport."
      );
      return "";
    }
    return toastRef.show(content, options);
  },
  update: (
    id: string,
    content: React.ReactNode | string,
    options?: ToastOptions
  ): void => {
    if (!toastRef.update) {
      console.warn(
        "Toast provider not initialized. Make sure you have wrapped your app with ToastProviderWithViewport."
      );
      return;
    }
    return toastRef.update(id, content, options);
  },
  dismiss: (id: string): void => {
    if (!toastRef.dismiss) {
      console.warn(
        "Toast provider not initialized. Make sure you have wrapped your app with ToastProviderWithViewport."
      );
      return;
    }
    return toastRef.dismiss(id);
  },
  dismissAll: (): void => {
    if (!toastRef.dismissAll) {
      console.warn(
        "Toast provider not initialized. Make sure you have wrapped your app with ToastProviderWithViewport."
      );
      return;
    }
    return toastRef.dismissAll();
  },
};

export { ToastProvider, useToast } from "./context/ToastContext";
export type { ToastOptions, ToastType, ToastPosition } from "./Toast.types";
```

### üß© Children
#### AccordianItem.tsx

```tsx
import React, { ReactNode } from "react";
import { View, StyleSheet } from "react-native";

export const AccordionItem = ({
  children,
  isActive,
  onToggle,
  className,
}: {
  children: ReactNode;
  isActive?: boolean;
  onToggle?: () => void;
  className?: string;
}) => {
  const [width, setWidth] = React.useState(0);
  return (
    <>
      <View
        className={"p-3" + className}
        onLayout={(e) => setWidth(e.nativeEvent.layout.width)}
      >
        {React.Children.map(children, (child) => {
          return React.cloneElement(child as React.ReactElement<any>, {
            isActive,
            onToggle,
          });
        })}
        <View
          style={[
            styles.accordionDivider,
            {
              width: width - 40,
            },
          ]}
        />
      </View>
    </>
  );
};

const styles = StyleSheet.create({
  accordionDivider: {
    height: 1,
    backgroundColor: "#404040",
    left: 10,
    width: 100,
    opacity: 0.54,
  },
});
```

#### AccordionContent.tsx

```tsx
import React, { ReactNode, useState, useEffect } from "react";
import { View, StyleSheet, LayoutChangeEvent } from "react-native";
import Animated, {
  Easing,
  withTiming,
  useSharedValue,
  useAnimatedStyle,
  withDelay,
  LinearTransition,
  FadeIn,
} from "react-native-reanimated";

export const AccordionContent = ({
  children,
  isActive = false,
  className = "",
}: {
  children: ReactNode;
  isActive?: boolean;
  className?: string;
}) => {
  const [contentHeight, setContentHeight] = useState(0);
  const animatedHeight = useSharedValue(0);
  const textOpacity = useSharedValue(0);
  const textTranslateY = useSharedValue(10);
  const [measured, setMeasured] = useState(false);
  const marginBottom = useSharedValue(0);

  const onLayout = (event: LayoutChangeEvent) => {
    const height = event.nativeEvent.layout.height;
    if (height > 0 && !measured) {
      setContentHeight(height);
      setMeasured(true);
    }
  };

  useEffect(() => {
    if (measured) {
      animatedHeight.value = withTiming(isActive ? contentHeight : 0, {
        duration: 500,
        easing: Easing.out(Easing.cubic),
      });

      if (isActive) {
        marginBottom.value = withTiming(10, {
          easing: Easing.linear,
        });
        textOpacity.value = withDelay(
          400,
          withTiming(1, { duration: 1000, easing: Easing.inOut(Easing.ease) })
        );
        textTranslateY.value = withDelay(
          300,
          withTiming(0, { duration: 250, easing: Easing.out(Easing.quad) })
        );
      } else {
        textOpacity.value = withTiming(0, { duration: 150 });
        textTranslateY.value = withTiming(10, { duration: 150 });
        marginBottom.value = withTiming(0, {
          easing: Easing.linear,
        });
      }
    }
  }, [isActive, measured, contentHeight]);

  const containerAnimatedStyle = useAnimatedStyle(() => ({
    height: animatedHeight.value,
    opacity: measured ? 1 : 0,
    marginBottom: marginBottom.value,
  }));

  const textAnimatedStyle = useAnimatedStyle(() => ({
    opacity: textOpacity.value,
    transform: [{ translateY: textTranslateY.value }],
  }));

  return (
    <>
      {!measured && (
        <Animated.View
          style={styles.measuringContainer}
          onLayout={onLayout}
          entering={FadeIn}
          layout={LinearTransition}
          className={className}
        >
          {children}
        </Animated.View>
      )}

      <Animated.View
        style={[styles.content, containerAnimatedStyle]}
        layout={LinearTransition}
      >
        <Animated.View style={textAnimatedStyle}>{children}</Animated.View>
      </Animated.View>
    </>
  );
};

const styles = StyleSheet.create({
  content: {
    overflow: "hidden",
    marginLeft: 10,
  },
  measuringContainer: {
    position: "absolute",
    opacity: 0,
    left: 0,
    right: 0,
  },
});
```

#### AccordionTrigger.tsx

```tsx
import React from "react";
import {
  TouchableOpacity,
  Text,
  StyleSheet,
  View,
  Pressable,
} from "react-native";
import { SymbolView } from "expo-symbols";
import Animated, {
  withTiming,
  Easing,
  useSharedValue,
  useAnimatedStyle,
} from "react-native-reanimated";

export const AccordionTrigger = ({
  children,
  isActive,
  onToggle,
  className = "",
}: {
  children: React.ReactNode;
  isActive?: boolean;
  onToggle?: () => void;
  className?: string;
}) => {
  const rotate = useSharedValue(0);

  React.useEffect(() => {
    rotate.value = withTiming(isActive ? 180 : 0, {
      duration: 400,
      easing: Easing.inOut(Easing.ease),
    });
  }, [isActive]);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      transform: [{ rotate: `${rotate.value}deg` }],
    };
  });

  return (
    <Pressable onPress={onToggle} style={styles.trigger} className={className}>
      <View style={styles.triggerContent}>
        <Text style={[styles.triggerText]}>{children}</Text>
        <Animated.View style={[styles.chevronContainer, animatedStyle]}>
          <SymbolView
            name="chevron.down"
            size={12}
            tintColor="#fff"
            resizeMode="scaleAspectFit"
          />
        </Animated.View>
      </View>
    </Pressable>
  );
};

const styles = StyleSheet.create({
  trigger: {
    padding: 10,
    backgroundColor: "#000",
  },
  triggerContent: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
  },
  triggerText: {
    fontSize: 16,
    fontWeight: "bold",
    color: "#fff",
  },
  triggerActive: {
    fontWeight: "bold",
    color: "#007bff",
  },
  chevronContainer: {
    marginLeft: 10,
  },
});
```

#### ShimmerTextWrapper.tsx

```tsx
import { View, Text } from "react-native";
import React from "react";

export const ShimmerTextWrapper = () => {
  return (
    <View>
      <Text>ShimmerTextWrapper</Text>
    </View>
  );
};
```

#### Breadcrumbs.tsx

```tsx
import React from "react";
import { View, StyleSheet } from "react-native";
import type { BreadcrumbsProps } from "../Breadcrumbs.types";

export const Breadcrumbs: React.FC<BreadcrumbsProps> = ({
  children,
  style,
}) => {
  return <View style={[styles.container, style]}>{children}</View>;
};

const styles = StyleSheet.create({
  container: {
    flexDirection: "row",
    alignItems: "center",
    flexWrap: "wrap",
  },
});
```

#### BreadcrumbsIcon.tsx

```tsx
import React from "react";
import { View, StyleSheet } from "react-native";
import type { BreadcrumbsProps } from "../Breadcrumbs.types";

export const BreadcrumbsIcon: React.FC<BreadcrumbsProps> = ({
  children,
  style,
}) => {
  return <View style={[styles.container, style]}>{children}</View>;
};

const styles = StyleSheet.create({
  container: {
    marginRight: 4,
  },
});
```

#### BreadcrumbsItem.tsx

```tsx
import React from "react";
import { View, Text, TouchableOpacity, StyleSheet } from "react-native";
import type { BreadcrumbItemProps } from "../Breadcrumbs.types";

export const BreadcrumbsItem: React.FC<BreadcrumbItemProps> = ({
  children,
  onPress,
  isCurrent,
  tint = "#888",
  currentTint = "#000",
  className,
}) => {
  const content = (
    <Text
      className={`${className}`}
      style={[
        isCurrent
          ? { color: currentTint, fontWeight: "500" }
          : {
              color: tint,
            },
      ]}
    >
      {children}
    </Text>
  );

  return onPress && !isCurrent ? (
    <TouchableOpacity onPress={onPress}>{content}</TouchableOpacity>
  ) : (
    content
  );
};

const styles = StyleSheet.create({
  item: {
    flexDirection: "row",
    alignItems: "center",
  },
  icon: {
    marginRight: 4,
  },
  link: {
    color: "#007AFF",
  },
  current: {
    fontWeight: "600",
    color: "#000",
  },
});
```

#### BreadcrumbsSeparator.tsx

```tsx
import React from "react";
import { Text, StyleSheet, View } from "react-native";
import type { BreadcrumbsSeparatorProps } from "../Breadcrumbs.types";

export const BreadcrumbsSeparator: React.FC<BreadcrumbsSeparatorProps> = ({
  children = "/",
}) => {
  return (
    <View style={styles.separator}>
      {children ? children : <Text style={{ color: "#888" }}>{children}</Text>}
    </View>
  );
};

const styles = StyleSheet.create({
  separator: {
    marginHorizontal: 4,
    color: "#888",
  },
});
```

#### BreadcrumbsView.tsx

```tsx
import React from "react";
import { StyleSheet, View } from "react-native";
import type { BreadcrumbsSeparatorProps } from "../Breadcrumbs.types";

/**
 *
 * @deprecated
 */
export const BreadcrumbsView: React.FC<BreadcrumbsSeparatorProps> = ({
  children,
}) => {
  return <View style={styles.item}>{children}</View>;
};

const styles = StyleSheet.create({
  item: {
    flexDirection: "row",
    alignItems: "center",
  },
});
```

#### CardWrapper.tsx

```tsx
import { View, Text, StyleSheet } from "react-native";
import React from "react";
import { CardWrapperProps } from "../Card.types";

export const CardWrapper: React.FC<CardWrapperProps> = ({
  children,
  className,
  style,
}): React.ReactNode => {
  return (
    <View className="" style={[styles.container, style]}>
      <View className="justify-cente">{children}</View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    justifyContent: "center",

    padding: 15,
    marginTop: 5,
  },
});
```

#### Footer.tsx

```tsx
import React from "react";
import {
  View,
  StyleSheet,
  StyleProp,
  ViewStyle,
  useWindowDimensions,
} from "react-native";

interface FooterProps {
  children: React.ReactNode;
  style?: StyleProp<ViewStyle>;
}

export const Footer: React.FC<FooterProps> = ({
  children,

  style,
}) => {
  const { height: windowHeight } = useWindowDimensions();

  return (
    <View
      style={[
        styles.contentContainer,
        { position: "absolute", bottom: 20, width: "100%" },
      ]}
    >
      <View
        style={[
          styles.container,
          style,
          {
            height: windowHeight * 0.1,
          },
        ]}
      >
        {children}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  contentContainer: {
    justifyContent: "center",
    alignItems: "center",
  },
  container: {
    padding: 16,
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    width: "100%",
  },
});
```

#### Subtitle.tsx

```tsx
import { View, Text, StyleSheet, TextStyle, StyleProp } from "react-native";
import React from "react";

interface SubTitleProps {
  children: React.ReactNode;
  className?: string;
  style?: StyleProp<TextStyle>;
}

export const SubTitle: React.FunctionComponent<SubTitleProps> = ({
  children,
  className,
  style,
}): React.ReactNode => {
  return (
    <Text
      className="font-medium text-gray-300 text-sm"
      numberOfLines={2}
      style={style}
    >
      {children}
    </Text>
  );
};

const styles = StyleSheet.create({
  container: {
    // backgroundColor: "#fff",
    height: 80,
  },
});
```

#### Title.tsx

```tsx
import { View, Text, StyleSheet, StyleProp, TextStyle } from "react-native";
import React from "react";

interface TitleProps {
  children: React.ReactNode;
  style?: StyleProp<TextStyle>;
}

export const Title: React.FunctionComponent<TitleProps> = ({
  children,
  style,
}): React.ReactNode => {
  return (
    <Text
      className={"font-bold text-gray-100 text-2xl"}
      numberOfLines={2}
      style={style}
    >
      {children}
    </Text>
  );
};

const styles = StyleSheet.create({
  container: {
    // backgroundColor: "#fff",
    height: 80,
  },
});
```

#### LeadingIcon.tsx

```tsx
import { Text } from "react-native";
import * as React from "react";

interface LeadingIconProps {
  children: React.ReactNode;
}
export const LeadingIcon: React.FC<LeadingIconProps> &
  React.FunctionComponent<LeadingIconProps> = ({
  children,
}): React.ReactNode & React.JSX.Element => {
  return <React.Fragment>{children}</React.Fragment>;
};
```

#### SubTitle.tsx

```tsx
import { StyleProp, Text, TextStyle } from "react-native";
import * as React from "react";

interface SubTitleProps {
  children: React.ReactNode;
  style?: StyleProp<TextStyle>;
}

export const SubTitle: React.FC<SubTitleProps> &
  React.FunctionComponent<SubTitleProps> = ({
  children,
  style = {},
}): React.ReactNode & React.JSX.Element => {
  return (
    <Text
      className="text-gray-300 text-sm"
      style={[style as StyleProp<TextStyle>]}
    >
      {children as string}
    </Text>
  );
};
```

#### Title.tsx

```tsx
import { StyleProp, Text, TextStyle, View } from "react-native";
import * as React from "react";

interface TitleProps {
  children: React.ReactNode;
  destructive?: boolean;
  style?: StyleProp<TextStyle>;
}

export const Title: React.FC<TitleProps> &
  React.FunctionComponent<TitleProps> = ({
  children,
  destructive,
  style = {},
  ...props
}): React.ReactNode & React.JSX.Element => {
  return (
    <Text
      className={
        destructive
          ? "text-[#3a3a3a] font-medium text-lg"
          : "text-white font-medium text-lg"
      }
      style={[
        style as TextStyle,
        {
          color: destructive ? "#EF4444" : "#ffffff",
        },
      ]}
      {...props}
    >
      {children}
    </Text>
  );
};
```

#### TitleView.tsx

```tsx
import { Text, View } from "react-native";
import * as React from "react";

interface TitleViewProps {
  children: React.ReactNode;
}

export const Title: React.FC<TitleViewProps> &
  React.FunctionComponent<TitleViewProps> = ({
  children,
}): React.ReactNode & React.JSX.Element => {
  return <View className="flex-1 justify-center ml-4">{children}</View>;
};
```

#### TrailingIcon.tsx

```tsx
import { Text, View } from "react-native";
import * as React from "react";

interface TrailingIconProps {
  children: React.ReactNode;
}

export const TrailingIcon: React.FC<TrailingIconProps> &
  React.FunctionComponent<TrailingIconProps> = ({
  children,
}): React.ReactNode & React.JSX.Element => {
  return <View className="items-center justfy-center">{children}</View>;
};
```

#### Wrapper.tsx

```tsx
import { View } from "react-native";
import * as React from "react";

interface WrapperProps {
  children: React.ReactNode;
}

export const Wrapper: React.FC<WrapperProps> &
  React.FunctionComponent<WrapperProps> = ({
  children,
}): React.ReactNode & React.JSX.Element => {
  return (
    <View className="p-3">
      <View className="flex-row items-center">{children}</View>
    </View>
  );
};
```

#### SearchBar.tsx

```tsx
import React, { useState, useRef, useEffect } from "react";
import {
  View,
  TextInput,
  TouchableOpacity,
  StyleSheet,
  Text,
  Dimensions,
  Pressable,
} from "react-native";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  interpolate,
  Easing,
  runOnJS,
  useAnimatedReaction,
} from "react-native-reanimated";
import { SymbolView } from "expo-symbols";
import { BlurView } from "expo-blur";
import { SearchBarProps } from "./SearchBar.types";

const AnimatedTouchable = Animated.createAnimatedComponent(TouchableOpacity);
const AnimatedView = Animated.createAnimatedComponent(View);
const AnimatedTextInput = Animated.createAnimatedComponent(TextInput);

const { width: screenWidth } = Dimensions.get("window");

export const SearchBar = ({
  placeholder = "Search",
  onSearch,
  onClear,
  style,
  renderLeadingIcons,
  renderTrailingIcons,
  onSearchDone = () => {},
  onSearchMount = () => {},
  containerWidth,
  focusedWidth,
  cancelButtonWidth = 68,
  enableWidthAnimation = true,
  centerWhenUnfocused = true,
  ...props
}: SearchBarProps) => {
  const [query, setQuery] = useState("");
  const [isFocused, setIsFocused] = useState(false);
  const [containerDimensions, setContainerDimensions] = useState({ width: 0 });
  const inputRef = useRef<TextInput>(null);

  const focusProgress = useSharedValue(0);
  const clearButtonScale = useSharedValue(0);
  const clearButtonOpacity = useSharedValue(0);
  const textOpacity = useSharedValue(1);
  const textScale = useSharedValue(1);
  const textTranslateY = useSharedValue(0);
  const currentWidth = useSharedValue(containerWidth || screenWidth - 32);

  // Update width when container dimensions change
  useEffect(() => {
    if (containerWidth) {
      currentWidth.value = containerWidth;
    } else if (containerDimensions.width > 0) {
      currentWidth.value = containerDimensions.width;
    }
  }, [containerWidth, containerDimensions.width]);

  const animatedContainerStyle = useAnimatedStyle(() => {
    if (!enableWidthAnimation) {
      return { width: currentWidth.value };
    }

    const searchBarWidth = interpolate(
      focusProgress.value,
      [0, 1],
      [
        currentWidth.value,
        focusedWidth || currentWidth.value - cancelButtonWidth,
      ],
    );
    return { width: searchBarWidth };
  });

  const animatedCancelStyle = useAnimatedStyle(() => {
    const opacity = interpolate(focusProgress.value, [0, 0.5, 1], [0, 0, 1]);
    const translateX = interpolate(focusProgress.value, [0, 1], [20, 0]);
    return {
      opacity,
      transform: [{ translateX }],
    };
  });

  const animatedSearchContentStyle = useAnimatedStyle(() => {
    const justifyContent =
      focusProgress.value === 0 && centerWhenUnfocused
        ? "center"
        : "flex-start";
    const paddingLeft = interpolate(focusProgress.value, [0, 1], [0, 12]);
    return { justifyContent, paddingLeft };
  });

  const animatedInputWrapperStyle = useAnimatedStyle(() => {
    if (!centerWhenUnfocused) {
      return { transform: [{ translateX: 0 }] };
    }

    const iconAndPadding = 40;
    const _centerOffSetValue = props?.textCenterOffset ?? 2.5;
    const centerOffset =
      (currentWidth.value - iconAndPadding * _centerOffSetValue) / 2 - 10;

    const translateX = interpolate(
      focusProgress.value,
      [0, 1],
      [centerOffset, 0],
      { extrapolateLeft: "clamp", extrapolateRight: "clamp" },
    );

    return {
      transform: [{ translateX }],
    };
  });

  const animatedIconStyle = useAnimatedStyle(() => {
    if (!centerWhenUnfocused) {
      return { transform: [{ translateX: 0 }] };
    }
    const _iconCenterValue = props?.iconCenterOffset ?? 2.5;
    const centerOffset = (currentWidth.value - 36 * _iconCenterValue) / 2 - 10;
    const translateX = interpolate(
      focusProgress.value,
      [0, 1],
      [centerOffset, 0],
      { extrapolateLeft: "clamp", extrapolateRight: "clamp" },
    );

    return {
      transform: [{ translateX }],
    };
  });

  const animatedClearButtonStyle = useAnimatedStyle(() => ({
    transform: [{ scale: clearButtonScale.value }],
    opacity: clearButtonOpacity.value,
  }));

  const animatedInputStyle = useAnimatedStyle(() => {
    return {
      opacity: textOpacity.value,
      transform: [
        { scale: textScale.value },
        { translateY: textTranslateY.value },
      ],
    };
  });

  const animateTextChange = () => {
    textScale.value = withSpring(0.95, {
      damping: 15,
      stiffness: 150,
    });
    textTranslateY.value = withSpring(-2, {
      damping: 15,
      stiffness: 150,
    });

    setTimeout(() => {
      textScale.value = withSpring(1, {
        damping: 15,
        stiffness: 150,
      });
      textTranslateY.value = withSpring(0, {
        damping: 15,
        stiffness: 150,
      });
    }, 50);
  };

  const handleFocus = () => {
    onSearchMount();
    setIsFocused(true);
    focusProgress.value = withSpring(1, {
      damping: 20,
      stiffness: 200,
      mass: 0.8,
      velocity: 0.5,
      duration: 550 as any,
    });
  };

  const handleCancel = () => {
    inputRef.current?.blur();
    setIsFocused(false);
    setQuery("");
    onSearchDone();
    onClear?.();
    focusProgress.value = withTiming(0);
    clearButtonScale.value = withTiming(0);
    clearButtonOpacity.value = withTiming(0, { duration: 200 });
  };

  const handleBlur = () => {
    if (!query) handleCancel();
  };

  const handleChangeText = (text: string) => {
    setQuery(text);
    animateTextChange();

    if (text.length > 0) {
      clearButtonScale.value = withSpring(1);
      clearButtonOpacity.value = withTiming(1, { duration: 200 });
      textOpacity.value = withTiming(1, { duration: 150 });
    } else {
      clearButtonScale.value = withSpring(0);
      clearButtonOpacity.value = withTiming(0, { duration: 200 });
    }

    onSearch?.(text);
  };

  const handleClear = () => {
    textOpacity.value = withTiming(0, { duration: 150 }, () => {
      runOnJS(setQuery)("");
      textOpacity.value = withTiming(1, { duration: 150 });
    });

    clearButtonScale.value = withTiming(0);
    clearButtonOpacity.value = withTiming(0, { duration: 200 });
    onClear?.();
    inputRef.current?.focus();
  };

  const handleLayout = (event: any) => {
    const { width } = event.nativeEvent.layout;
    setContainerDimensions({ width });
  };

  return (
    <View style={[styles.container, style]} onLayout={handleLayout}>
      <View style={styles.searchRow}>
        <AnimatedView
          style={[styles.searchBarContainer, animatedContainerStyle]}
        >
          <BlurView
            intensity={15}
            tint="systemChromeMaterialDark"
            style={styles.blurContainer}
          >
            <View style={styles.searchContainer}>
              <AnimatedView
                style={[styles.searchContent, animatedSearchContentStyle]}
              >
                <AnimatedView
                  style={[
                    styles.searchIconContainer,
                    animatedIconStyle,
                    props?.iconStyle,
                  ]}
                >
                  {renderLeadingIcons ? (
                    renderLeadingIcons()
                  ) : (
                    <SymbolView
                      name="magnifyingglass"
                      size={18}
                      tintColor="#8E8E93"
                    />
                  )}
                </AnimatedView>

                <AnimatedView style={[{ flex: 1 }, animatedInputWrapperStyle]}>
                  <AnimatedTextInput
                    ref={inputRef}
                    style={[
                      styles.input,
                      animatedInputStyle,
                      props?.inputStyle,
                    ]}
                    cursorColor={props?.tint ?? "#007AFF"}
                    placeholder={placeholder}
                    placeholderTextColor="#8E8E93"
                    value={query}
                    onChangeText={handleChangeText}
                    onFocus={handleFocus}
                    onBlur={handleBlur}
                    returnKeyType="search"
                    autoCorrect={false}
                    autoCapitalize="none"
                    selectionColor={props?.tint ?? "#007AFF"}
                    {...props}
                  />
                </AnimatedView>

                {query.length > 0 && (
                  <AnimatedTouchable
                    onPress={handleClear}
                    style={[styles.clearButton, animatedClearButtonStyle]}
                    hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                  >
                    {renderTrailingIcons ? (
                      renderTrailingIcons()
                    ) : (
                      <SymbolView
                        name="xmark.circle.fill"
                        size={18}
                        tintColor="#8E8E93"
                      />
                    )}
                  </AnimatedTouchable>
                )}
              </AnimatedView>
            </View>
          </BlurView>
        </AnimatedView>

        <AnimatedView
          style={[styles.cancelButtonContainer, animatedCancelStyle]}
        >
          <TouchableOpacity
            onPress={handleCancel}
            style={styles.cancelButton}
            activeOpacity={0.6}
            hitSlop={{ top: 10, bottom: 10, left: 5, right: 5 }}
          >
            <Text
              style={[
                styles.cancelText,
                {
                  color: props?.tint ?? "#007AFF",
                },
              ]}
            >
              Cancel
            </Text>
          </TouchableOpacity>
        </AnimatedView>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    width: "100%",
    paddingHorizontal: 0,
    paddingVertical: 8,
  },
  searchRow: {
    flexDirection: "row",
    alignItems: "center",
  },
  searchBarContainer: {},
  blurContainer: {
    borderRadius: 12,
    overflow: "hidden",
  },
  searchContainer: {
    backgroundColor: "rgba(118, 118, 128, 0.12)",
    borderRadius: 12,
    minHeight: 35,
    justifyContent: "center",
  },
  searchContent: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 12,
    paddingVertical: 10,
  },
  searchIconContainer: {
    width: 20,
    height: 20,
    justifyContent: "center",
    alignItems: "center",
    marginRight: 8,
  },
  input: {
    width: "100%",
    color: "#FFFFFF",
    fontSize: 17,
    fontFamily: "System",
    fontWeight: "400",

    includeFontPadding: false,
    textAlignVertical: "center",
    minHeight: 24,

    textAlign: "left",
  },
  clearButton: {
    padding: 4,
    marginLeft: 4,
  },
  cancelButtonContainer: {
    paddingLeft: 12,
    minWidth: 60,
    justifyContent: "center",
    alignItems: "flex-start",
  },
  cancelButton: {
    paddingVertical: 8,
    paddingHorizontal: 4,
  },
  cancelText: {
    fontSize: 17,
    fontFamily: "System",
    fontWeight: "400",
  },
});
```

#### SearchBar.types.ts

```tsx
import type {
  TextInputProps,
  ViewStyle,
  TextStyle,
  DimensionValue,
  StyleProp,
} from "react-native";

export interface SearchBarProps {
  /**
   * Placeholder text for the search input
   * @default "Search..."
   */
  placeholder?: string;
  /**
   * Callback when search text changes
   */
  onSearch?: (query: string) => void;
  /**
   * Callback when search is cleared
   */
  onClear?: () => void;
  /**
   * Additional style for the container
   */
  style?: ViewStyle;
  /**
   * Style for the input
   */
  inputStyle?: TextStyle;
  /**
   * Width of the search bar
   * @default "100%"
   */
  width?: DimensionValue;
  /**
   * Maximum width of the search bar
   * @default screenWidth - 32
   */
  maxWidth?: number;
  /**
   * Height of the parent container
   * @default 40
   */
  parentHeight?: number | 40;
  /**
   * Tint color for the search
   */
  tint?: string;
  /**
   * Padding around the icon
   * @default 8
   */
  iconPadding?: number;

  renderTrailingIcons?: () => React.ReactNode;
  renderLeadingIcons?: () => React.ReactNode;

  onSearchDone?: () => void;

  onSearchMount?: () => void;

  // New flexibility props
  containerWidth?: number;
  focusedWidth?: number;
  cancelButtonWidth?: number;
  iconStyle?: StyleProp<ViewStyle>;
  enableWidthAnimation?: boolean;
  centerWhenUnfocused?: boolean;
  textCenterOffset?: number;
  iconCenterOffset?: number;
}
```

#### StepperButton.tsx

```tsx
import * as React from "react";
import { Pressable, StyleSheet, Text } from "react-native";
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withTiming,
  interpolateColor,
} from "react-native-reanimated";
import { useStepperContext } from "../../context/StepperContext";

import type { StepperButtonProps } from "./types";

const AnimatedPressable = Animated.createAnimatedComponent(Pressable);

export const StepperButton: React.FC<StepperButtonProps> = ({
  type,
  style,
  iconStyle,
  icon,
}: StepperButtonProps): React.ReactNode => {
  const { value, onChange, min, max, step, disabled, variant } =
    useStepperContext();

  const pressed = useSharedValue(0);

  const canDecrement = value > (min || 0);
  const canIncrement = value < (max || Infinity);

  const isDisabled =
    disabled ||
    (type === "decrement" && !canDecrement) ||
    (type === "increment" && !canIncrement);

  const handlePress = () => {
    if (isDisabled) return;

    const newValue =
      type === "increment" ? value + (step || 1) : value - (step || 1);

    onChange(newValue);
  };

  const animatedStyle = useAnimatedStyle(() => {
    const backgroundColor = interpolateColor(
      pressed.value,
      [0, 1],
      variant === "light"
        ? ["transparent", "rgba(0, 0, 0, 0.05)"]
        : ["transparent", "rgba(255, 255, 255, 0.1)"]
    );

    return {
      backgroundColor,
      opacity: isDisabled ? 0.4 : 1,
    };
  });

  return (
    <AnimatedPressable
      style={[styles.button, animatedStyle, style]}
      onPress={handlePress}
      disabled={isDisabled}
      onPressIn={() => {
        pressed.value = withTiming(1, { duration: 150 });
      }}
      onPressOut={() => {
        pressed.value = withTiming(0, { duration: 150 });
      }}
    >
      {icon || (
        <Text
          style={[
            styles.icon,
            variant === "dark" && styles.darkIcon,
            iconStyle,
          ]}
        >
          {type === "increment" ? "+" : "‚àí"}
        </Text>
      )}
    </AnimatedPressable>
  );
};

const styles = StyleSheet.create({
  button: {
    width: 36,
    height: 36,
    borderRadius: 18,
    justifyContent: "center",
    alignItems: "center",
  },
  icon: {
    fontSize: 18,
    color: "#000",
    fontWeight: "500",
  },
  darkIcon: {
    color: "#fff",
  },
});
```

#### types.ts

```tsx
import type { TextStyle, ViewStyle } from "react-native";

export interface StepperButtonProps {
  type: "increment" | "decrement";
  style?: ViewStyle;
  iconStyle?: TextStyle;
  icon?: React.ReactNode;
}
```

#### StepperContent.tsx

```tsx
import * as React from "react";
import { View, StyleSheet } from "react-native";
import type { StepperContentProps } from "./types";

export const StepperContent: React.FC<StepperContentProps> = ({
  children,
  style,
}: StepperContentProps): React.ReactNode => {
  return <View style={[styles.content, style]}>{children}</View>;
};

const styles = StyleSheet.create({
  content: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
  },
});
```

#### types.ts

```tsx
import type { ViewStyle } from "react-native";

export interface StepperContentProps {
  children: React.ReactNode;
  style?: ViewStyle;
}
```

#### StepperValue.tsx

```tsx
import * as React from "react";
import { StyleSheet } from "react-native";
import { Easing, ReduceMotion } from "react-native-reanimated";
import { useStepperContext } from "../../context/StepperContext";
import type { StepperValueProps } from "./types";
import { AnimatedRollingNumber } from "react-native-animated-rolling-numbers";

export const StepperValue: React.FC<StepperValueProps> = ({
  style,

  animationConfig = {
    duration: 500,
    reduceMotion: ReduceMotion.Never,
    easing: Easing.bounce,
  },
}: StepperValueProps): React.ReactNode => {
  const { value, variant } = useStepperContext();

  return (
    <AnimatedRollingNumber
      value={Number(value)}
      useGrouping={false}
      enableCompactNotation={false}
      compactToFixed={2}
      textStyle={[styles.value, style, variant === "dark" && styles.darkValue]}
      spinningAnimationConfig={animationConfig}
    />
  );
};

const styles = StyleSheet.create({
  value: {
    fontSize: 16,
    fontWeight: "500",
    color: "#000",

    textAlign: "center",
  },
  darkValue: {
    color: "#fff",
  },
});
```

#### types.ts

```tsx
import type { EasingFunction, TextStyle } from "react-native";
import { EasingFunctionFactory, ReduceMotion } from "react-native-reanimated";

export interface StepperValueProps {
  style?: TextStyle;

  animationConfig?: {
    duration?: number;
    reduceMotion?: ReduceMotion;
    easing?: EasingFunction | EasingFunctionFactory;
  };
}
```

### üìÅ Other
#### index.ts

```ts
export * from "./Accordian";
export * from "./children/AccordionContent";
export * from "./children/AccordianItem";
export * from "./children/AccordionTrigger";
```

#### types.ts

```ts
import type { ReactNode } from "react";

interface AccordionType {
  children: ReactNode;
  className?: string;
}

interface AccordionTriggerTypes {
  children: React.ReactNode;
  isActive?: boolean;
  onToggle?: () => void;
  className?: string;
}

interface AccordionContentTypes {
  children: ReactNode;
  isActive?: boolean;
  className?: string;
}

interface AccordionItemTypes {
  children: ReactNode;
  isActive?: boolean;
  onToggle?: () => void;
  className?: string;
}

export {
  AccordionContentTypes,
  AccordionItemTypes,
  AccordionTriggerTypes,
  AccordionType,
};
```

#### index.ts

```ts
export * from "./AnimatedMaskedText";
```

#### constants.ts

```ts
import type { SFSymbol } from "expo-symbols";

type WalletAction = {
  title: string;
  sfSymbol: SFSymbol;
  overlayIcon?: SFSymbol;
  description: string;
  tint: string;
  descrutive?: boolean;
};

export const walletActions: WalletAction[] = [
  {
    title: "Block the card",
    sfSymbol: "wallet.pass",
    overlayIcon: "lock.circle",
    description: "Block the card to prevent unauthorized use.",
    tint: "gray",
  },
  {
    title: "Change PIN",
    sfSymbol: "wallet.pass",
    overlayIcon: "magnifyingglass.circle",
    description: "Change the PIN code of your card.",
    tint: "gray",
  },
  {
    title: "Card settings",
    sfSymbol: "wallet.pass",
    overlayIcon: "pencil.circle",
    description: "Manage your card settings.",
    tint: "gray",
  },
  {
    title: "Deactivate card",
    sfSymbol: "wallet.pass",
    overlayIcon: "creditcard.circle",
    description: "Deactivate the card completely.",
    tint: "red",
    descrutive: true,
  },
];
```

#### index.ts

```ts
export { BottomSheet } from "./BottomSheet";
export type { BottomSheetProps } from "./BottomSheet.types";
```

#### index.ts

```ts
export { BreadcrumbsItem } from "./children/BreadcrumbsItem";
export { BreadcrumbsSeparator } from "./children/BreadcrumbsSeparator";
export { Breadcrumbs } from "./children/Breadcrumbs";
export { BreadcrumbsIcon } from "./children/BreadcrumbsIcon";
export { BreadcrumbsView } from "./children/BreadcrumbsView";

export { BreadcrumbsList } from "./BreadcrumbsList";
export * from "./BreadcrumbsList";
```

#### index.ts

```ts
export * from "./Card";
// export { Title as CardTitle } from "./children/Title";
// export { CardWrapper as CardWrapper } from "./children/CardWrapper";
// export { SubTitle as CardSubtitle } from "./children/Subtitle";
// export { Footer as CardFooter } from "./children/Footer";
```

#### index.ts

```ts
export { ListItem } from "./List";
export { LeadingIcon as ListItemLeadingIcon } from "./children/LeadingIcon";
export { SubTitle as ListItemSubTitle } from "./children/SubTitle";
export { Title as ListItemTitle } from "./children/Title";
export { TrailingIcon as ListItemTrailingIcon } from "./children/TrailingIcon";
export { Title as ListItemTitleView } from "./children/TitleView";
export { Wrapper as ListItemWrapper } from "./children/Wrapper";
```

#### index.ts

```ts
export * from "./dots/PlusingDots.Indicator";
export * from "./dots/OrbitingDots.Indicator";
export * from "./rotate/SpinnerArc.Indicator";
export * from "./segment/SegmentSpinner.Indicator";

export * from "./circle/Circle.Indiactor";
export * from "./square/rotate/RotateSquare.Indicator";
```

#### StepperContext.ts

```ts
import { createContext, useContext } from "react";
import type { StepperContextProps } from "./types";

export const StepperContext = createContext<StepperContextProps | undefined>(
  undefined
);

export const useStepperContext = () => {
  const context = useContext(StepperContext);

  if (!context) {
    throw new Error(
      "Stepper components must be used within a Stepper component"
    );
  }

  return context;
};
```

#### types.ts

```ts
export interface StepperContextProps {
  value: number;
  onChange: (newValue: number) => void;
  min?: number;
  max?: number;
  step?: number;
  disabled?: boolean;
  variant?: "light" | "dark";
}
```

#### index.ts

```ts
export * from "./Steppper";
export * from "./children/button/StepperButton";
export * from "./children/value/StepperValue";
export * from "./children/content/StepperContent";
```

#### useToast.ts

```ts
import { useContext } from "react";
import { ToastContextValue } from "../Toast.types";

export const useToast = <T extends ToastContextValue>(
  ReactContext: React.Context<T>
): ToastContextValue => {
  const context = useContext(ReactContext);
  if (!context) {
    throw new Error("useToast must be used within a ToastProvider");
  }
  return context;
};
```

#### index.ts

```ts
export * from "./Accordian";
export * from "./AnimatedMaskedText";
export * from "./BottomSheet";
export * from "./Breadcrumbs";
export * from "./Card";
export * from "./List";
export * from "./Loaders";
export * from "./SearchBar/children/SearchBar";
export * from "./Stepper";
export * from "./Toast";
export * from "./Timeline/TimelineView";
export * from "./Pagination/Pagination";
export * from "./Chip/Chip";
export * from "./Shimmer/Shimmer";
export * from "./SeekBar/SeekBar";
```
