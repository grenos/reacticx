---
title: Calendar View
description: A flexible and beautiful calendar component for React Native with custom themeing.
links:
  source: https://github.com/rit3zh/glow-ui/blob/main/src/components/calendar/CalendarView.tsx
---

import { SiNpm } from "react-icons/si";
import { TbManualGearbox } from "react-icons/tb";
import {
  Tab,
  Tabs,
  TabsList,
  TabsTrigger,
  TabsContent,
} from "fumadocs-ui/components/tabs";
import { Accordion, Accordions } from "fumadocs-ui/components/accordion";
import { TypeTable } from "fumadocs-ui/components/type-table";

<div className="flex justify-center items-center my-8">
  <video
    src="/static/media/calendar.mp4"
    autoPlay
    muted
    loop
    className="rounded-2xl"
    style={{ width: "40%", height: "auto" }}
  />
</div>

### Installation

<Tabs defaultValue="tab-1">
  <TabsList>
    <TabsTrigger value="tab-1">
      <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
        <SiNpm />
        <span>NPM</span>
      </div>
    </TabsTrigger>

    <TabsTrigger value="tab-2">
      <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
        <TbManualGearbox />
        <span>Manual</span>
      </div>
    </TabsTrigger>

  </TabsList>

<TabsContent value="tab-1">

```bash
npx rn-glow add calendar
```

## ðŸ§© `CalendarViewProps`

<TypeTable
  type={{
    initialDate: { type: "string", description: "Initial date to show." },
    initialMode: {
      type: '"date" | "month" | "year" | "month-year" | "time"',
      description: "Initial calendar mode.",
    },
    enableRangeMode: {
      type: "boolean",
      description: "Enable date range selection mode.",
    },
    showModeSelector: {
      type: "boolean",
      description: "Toggle the visibility of the mode selector.",
    },
    showRangeToggle: {
      type: "boolean",
      description: "Toggle the range mode on/off in UI.",
    },
    theme: {
      type: "Partial<typeof darkTheme>",
      description: "Theme override object.",
    },
    onDateSelect: {
      type: "(date: string) => void",
      description: "Callback when a date is selected.",
    },
    onRangeSelect: {
      type: "(range: DateRange) => void",
      description: "Callback when a date range is selected.",
    },
    onTimeSelect: {
      type: '(time: { hour: number; minute: number; period: "AM" | "PM" }) => void',
      description: "Callback when time is selected (time mode).",
    },
    onModeChange: {
      type: "(mode: CalendarMode) => void",
      description: "Triggered when mode is changed.",
    },
    dateFormat: {
      type: "string",
      description: "Custom date format (e.g. YYYY-MM-DD).",
    },
    minDate: {
      type: "string",
      description: "Minimum selectable date.",
    },
    maxDate: {
      type: "string",
      description: "Maximum selectable date.",
    },
    disabledDates: {
      type: "string[]",
      description: "List of dates to disable.",
    },
    renderTrigger: {
      type: "(params: { selectedValue: string; onPress: () => void; isRangeMode: boolean }) => React.ReactNode",
      description: "Custom trigger render function.",
    },
    hideTrigger: {
      type: "boolean",
      description: "Hide default trigger button.",
    },
    sheetSizes: {
      type: "(string | number)[]",
      description: "Custom sheet sizes for modal.",
    },
  }}
/>

---

## ðŸ“¡ `CalendarViewRef`

<TypeTable
  type={{
    open: {
      type: "() => void",
      description: "Programmatically open calendar.",
    },
    close: {
      type: "() => void",
      description: "Programmatically close calendar.",
    },
    reset: { type: "() => void", description: "Reset the calendar selection." },
    goToToday: { type: "() => void", description: "Jump to today's date." },
    getValue: {
      type: "() => string | DateRange",
      description: "Returns the selected date or range.",
    },
    setDate: {
      type: "(date: string) => void",
      description: "Sets the current selected date.",
    },
    setRange: {
      type: "(range: DateRange) => void",
      description: "Sets the current selected range.",
    },
  }}
/>

</TabsContent>

  <TabsContent value="tab-2">
    <Accordions type="multiple">
      <Accordion title="CalendarView.tsx">
      ```tsx
      import React, {
  useState,
  useRef,
  useCallback,
  useMemo,
  forwardRef,
  useImperativeHandle,
  memo,
} from "react";
import {
  View,
  Text,
  Pressable,
  TextInput,
  Switch,
  ScrollView,
  FlatList,
} from "react-native";
import moment from "moment";
import { TrueSheet } from "@lodev09/react-native-true-sheet";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
  withSpring,
  withSequence,
  FadeIn,
  Easing,
} from "react-native-reanimated";
import { SymbolView } from "expo-symbols";
import {
  CalendarConfig,
  CalendarDate,
  CalendarMode,
  CalendarViewProps,
  CalendarViewRef,
  DateRange,
} from "./Calendar.props";
import { darkTheme } from "./constants";
import { calenderStyles as styles } from "./styles";

const calendarModes: Record<CalendarMode, CalendarConfig> = {
date: {
mode: "date",
title: "Select Date",
format: "MMMM D, YYYY",
viewMode: "day",
},
month: {
mode: "month",
title: "Select Month",
format: "MMMM YYYY",
viewMode: "month",
},
year: {
mode: "year",
title: "Select Year",
format: "YYYY",
viewMode: "year",
},
"month-year": {
mode: "month-year",
title: "Select Month & Year",
format: "MMMM YYYY",
viewMode: "month",
},
time: {
mode: "time",
title: "Select Date & Time",
format: "MMMM D, YYYY h:mm A",
viewMode: "day",
},
};

const CalendarDay = memo<{
item: CalendarDate;
onPress: (date: string) => void;
theme: typeof darkTheme;
disabled: boolean;
}>(({ item, onPress, theme, disabled }) => {
const handlePress = useCallback(() => {
if (!disabled) {
onPress(item.date);
}
}, [disabled, onPress, item.date]);

const dayStyle = useMemo(
() => [
styles.dayCell,
!item.isCurrentMonth && { opacity: 0.3 },
item.isToday && {
backgroundColor: theme.info + "20",
borderWidth: 2,
borderColor: theme.info,
},
item.isSelected && {
backgroundColor: theme.primary,
shadowColor: theme.primary,
shadowOffset: { width: 0, height: 4 },
shadowOpacity: 0.3,
shadowRadius: 8,
elevation: 6,
},
item.isInRange && { backgroundColor: theme.primary + "30" },
item.isRangeStart && {
backgroundColor: theme.primary,
borderTopRightRadius: 6,
borderBottomRightRadius: 6,
},
item.isRangeEnd && {
backgroundColor: theme.primary,
borderTopLeftRadius: 6,
borderBottomLeftRadius: 6,
},
disabled && { opacity: 0.4 },
],
[item, theme, disabled],
);

const textStyle = useMemo(
() => [
styles.dayText,
{ color: theme.foreground },
!item.isCurrentMonth && { color: theme.mutedForeground },
item.isToday && { fontWeight: "800", color: theme.info },
(item.isSelected || item.isRangeStart || item.isRangeEnd) && {
color: theme.primaryForeground,
fontWeight: "800",
},
item.isInRange &&
!item.isRangeStart &&
!item.isRangeEnd && {
color: theme.foreground,
fontWeight: "700",
},
],
[item, theme],
);

return (

<Pressable style={dayStyle} onPress={handlePress} disabled={disabled}>
<Text style={textStyle as any}>{item.day}</Text>
</Pressable>
);
});

const MonthCell = memo<{
month: string;
index: number;
isSelected: boolean;
onPress: (index: number) => void;
theme: typeof darkTheme;
}>(({ month, index, isSelected, onPress, theme }) => {
const handlePress = useCallback(() => onPress(index), [onPress, index]);

const cellStyle = useMemo(
() => [
styles.monthCell,
{ backgroundColor: theme.muted, borderColor: theme.border },
isSelected && {
backgroundColor: theme.primary,
shadowColor: theme.primary,
shadowOffset: { width: 0, height: 4 },
shadowOpacity: 0.3,
shadowRadius: 8,
elevation: 6,
},
],
[isSelected, theme],
);

const textStyle = useMemo(
() => [
styles.monthText,
{ color: theme.foreground },
isSelected && { color: theme.primaryForeground, fontWeight: "800" },
],
[isSelected, theme],
);

return (

<Pressable style={cellStyle} onPress={handlePress}>
<Text style={textStyle as any}>{month}</Text>
</Pressable>
);
});

// Memoized Year Cell Component
const YearCell = memo<{
year: number;
isSelected: boolean;
onPress: (year: number) => void;
theme: typeof darkTheme;
}>(({ year, isSelected, onPress, theme }) => {
const handlePress = useCallback(() => onPress(year), [onPress, year]);

const cellStyle = useMemo(
() => [
styles.yearCell,
{ backgroundColor: theme.muted, borderColor: theme.border },
isSelected && {
backgroundColor: theme.primary,
shadowColor: theme.primary,
shadowOffset: { width: 0, height: 4 },
shadowOpacity: 0.3,
shadowRadius: 8,
elevation: 6,
},
],
[isSelected, theme],
);

const textStyle = useMemo(
() => [
styles.yearText,
{ color: theme.foreground },
isSelected && { color: theme.primaryForeground, fontWeight: "800" },
],
[isSelected, theme],
);

return (

<Pressable style={cellStyle} onPress={handlePress}>
<Text style={textStyle as any}>{year}</Text>
</Pressable>
);
});

const TimePicker = memo<{
selectedTime: { hour: number; minute: number; period: "AM" | "PM" };
onTimeChange: (
type: "hour" | "minute" | "period",
value: number | string,
) => void;
theme: typeof darkTheme;
}>(({ selectedTime, onTimeChange, theme }) => {
const hours = useMemo(() => Array.from({ length: 12 }, (\_, i) => i + 1), []);
const minutes = useMemo(() => [0, 15, 30, 45], []);
const periods = useMemo(() => ["AM", "PM"] as const, []);

const renderHourItem = useCallback(
({ item }: { item: number }) => (

<Pressable
  style={[
    styles.timeOption,
    {
      backgroundColor: selectedTime.hour === item ? theme.primary : theme.muted,
      borderColor: selectedTime.hour === item ? theme.primary : theme.border,
    },
  ]}
  onPress={() => onTimeChange("hour", item)}
>
  <Text
    style={[
      styles.timeOptionText,
      {
        color:
          selectedTime.hour === item
            ? theme.primaryForeground
            : theme.foreground,
      },
    ]}
  >
    {item}
  </Text>
</Pressable>
), [selectedTime.hour, onTimeChange, theme], );

const renderMinuteItem = useCallback(
({ item }: { item: number }) => (

<Pressable
  style={[
    styles.timeOption,
    {
      backgroundColor:
        selectedTime.minute === item ? theme.primary : theme.muted,
      borderColor: selectedTime.minute === item ? theme.primary : theme.border,
    },
  ]}
  onPress={() => onTimeChange("minute", item)}
>
  <Text
    style={[
      styles.timeOptionText,
      {
        color:
          selectedTime.minute === item
            ? theme.primaryForeground
            : theme.foreground,
      },
    ]}
  >
    {item.toString().padStart(2, "0")}
  </Text>
</Pressable>
), [selectedTime.minute, onTimeChange, theme], );

return (

<Animated.View
style={[styles.timePickerContainer, { backgroundColor: theme.card }]}
entering={FadeIn.delay(300)} >
<View style={styles.timePickerHeader}>
<SymbolView
          name="clock.fill"
          size={22}
          type="hierarchical"
          tintColor={theme.primary}
        />
<Text style={[styles.timePickerLabel, { color: theme.foreground }]}>
Select Time
</Text>
</View>
<View style={styles.timePickerRow}>
{/* Hour picker */}
<View style={styles.timePicker}>
<Text
style={[styles.timePickerTitle, { color: theme.mutedForeground }]} >
Hour
</Text>
<FlatList
data={hours}
renderItem={renderHourItem}
keyExtractor={(item) => item.toString()}
style={styles.timePickerScroll}
showsVerticalScrollIndicator={false}
removeClippedSubviews={true}
maxToRenderPerBatch={6}
windowSize={10}
/>
</View>

        {/* Minute picker */}
        <View style={styles.timePicker}>
          <Text
            style={[styles.timePickerTitle, { color: theme.mutedForeground }]}
          >
            Minute
          </Text>
          <FlatList
            data={minutes}
            renderItem={renderMinuteItem}
            keyExtractor={(item) => item.toString()}
            style={styles.timePickerScroll}
            showsVerticalScrollIndicator={false}
            removeClippedSubviews={true}
          />
        </View>

        {/* Period picker */}
        <View style={styles.timePicker}>
          <Text
            style={[styles.timePickerTitle, { color: theme.mutedForeground }]}
          >
            Period
          </Text>
          <View style={styles.timePickerOptions}>
            {periods.map((period) => (
              <Pressable
                key={period}
                style={[
                  styles.timeOption,
                  {
                    backgroundColor:
                      selectedTime.period === period
                        ? theme.primary
                        : theme.muted,
                    borderColor:
                      selectedTime.period === period
                        ? theme.primary
                        : theme.border,
                  },
                ]}
                onPress={() => onTimeChange("period", period)}
              >
                <Text
                  style={[
                    styles.timeOptionText,
                    {
                      color:
                        selectedTime.period === period
                          ? theme.primaryForeground
                          : theme.foreground,
                    },
                  ]}
                >
                  {period}
                </Text>
              </Pressable>
            ))}
          </View>
        </View>
      </View>
    </Animated.View>

);
});

export const CalendarView = forwardRef<CalendarViewRef, CalendarViewProps>(
  (
    {
      initialDate = moment().format("YYYY-MM-DD"),
      initialMode = "date",
      enableRangeMode = false,
      showModeSelector = true,
      showRangeToggle = true,
      theme: customTheme,
      onDateSelect,
      onRangeSelect,
      onTimeSelect,
      onModeChange,
      dateFormat,
      minDate,
      maxDate,
      disabledDates = [],
      renderTrigger,
      hideTrigger = false,
      sheetSizes = ["auto"],
    },
    ref,
  ) => {
    const theme = useMemo(
      () => ({ ...darkTheme, ...customTheme }),
      [customTheme],
    );

    const [selectedDate, setSelectedDate] = useState<string>(initialDate);
    const [selectedTime, setSelectedTime] = useState({
      hour: 12,
      minute: 0,
      period: "PM" as "AM" | "PM",
    });
    const [dateRange, setDateRange] = useState<DateRange>({
      start: null,
      end: null,
    });
    const [isRangeMode, setIsRangeMode] = useState(enableRangeMode);
    const [calendarMode, setCalendarMode] = useState<CalendarMode>(initialMode);
    const [currentMonth, setCurrentMonth] = useState(moment(initialDate));
    const [viewMode, setViewMode] = useState<"day" | "month" | "year">("day");
    const [yearFilter, setYearFilter] = useState("");

    const sheet = useRef<TrueSheet>(null);
    const scrollview = useRef<ScrollView>(null);

    const opacity = useSharedValue(0);
    const translateY = useSharedValue(20);
    const scale = useSharedValue(0.95);

    const isDateDisabled = useCallback(
      (date: string) => {
        if (disabledDates.includes(date)) return true;
        if (minDate && moment(date).isBefore(minDate)) return true;
        if (maxDate && moment(date).isAfter(maxDate)) return true;
        return false;
      },
      [disabledDates, minDate, maxDate],
    );

    const calendarDays = useMemo((): CalendarDate[] => {
      const startOfMonth = currentMonth.clone().startOf("month");
      const endOfMonth = currentMonth.clone().endOf("month");
      const startOfWeek = startOfMonth.clone().startOf("week");
      const endOfWeek = endOfMonth.clone().endOf("week");

      const days: CalendarDate[] = [];
      let day = startOfWeek.clone();

      while (day.isSameOrBefore(endOfWeek, "day")) {
        const dateStr = day.format("YYYY-MM-DD");
        const isInRange =
          isRangeMode &&
          dateRange.start &&
          dateRange.end &&
          day.isBetween(dateRange.start, dateRange.end, "day", "[]");

        days.push({
          date: dateStr,
          day: day.date(),
          isCurrentMonth: day.isSame(currentMonth, "month"),
          isToday: day.isSame(moment(), "day"),
          isSelected: !isRangeMode && dateStr === selectedDate,
          isInRange: isInRange || false,
          isRangeStart: isRangeMode && dateStr === dateRange.start,
          isRangeEnd: isRangeMode && dateStr === dateRange.end,
        });
        day.add(1, "day");
      }

      return days;
    }, [currentMonth, selectedDate, dateRange, isRangeMode]);

    const filteredYears = useMemo(() => {
      const currentYear = moment().year();
      const years = Array.from(
        { length: 201 },
        (_, i) => currentYear - 100 + i,
      );
      if (!yearFilter) return years;
      return years.filter((year) => year.toString().includes(yearFilter));
    }, [yearFilter]);

    const months = useMemo(() => moment.months(), []);

    const showCalendar = useCallback(() => {
      opacity.value = withTiming(1, {
        duration: 300,
        easing: Easing.out(Easing.quad),
      });
      translateY.value = withSpring(0, { damping: 20, stiffness: 300 });
      scale.value = withSpring(1, { damping: 20, stiffness: 300 });

      const config = calendarModes[calendarMode];
      setViewMode(config.viewMode);
      sheet.current?.present();
    }, [calendarMode]);

    const hideCalendar = useCallback(() => {
      opacity.value = withTiming(0, { duration: 250 });
      translateY.value = withTiming(30, { duration: 300 });
      scale.value = withTiming(0.9, { duration: 300 });

      setTimeout(() => {
        sheet.current?.dismiss();
      }, 250);
    }, []);

    const handleDateSelect = useCallback(
      (date: string) => {
        if (isDateDisabled(date)) return;

        if (calendarMode === "date" || calendarMode === "time") {
          if (isRangeMode) {
            if (!dateRange.start || (dateRange.start && dateRange.end)) {
              const newRange = { start: date, end: null };
              setDateRange(newRange);
              onRangeSelect?.(newRange);
            } else {
              const start = moment(dateRange.start);
              const end = moment(date);

              const finalRange = end.isBefore(start)
                ? { start: date, end: dateRange.start }
                : { start: dateRange.start, end: date };

              setDateRange(finalRange);
              onRangeSelect?.(finalRange);
            }
          } else {
            setSelectedDate(date);
            setCurrentMonth(moment(date));
            onDateSelect?.(date);

            if (calendarMode === "date") {
              scale.value = withSequence(
                withTiming(1.05, { duration: 100 }),
                withTiming(1, { duration: 150 }),
              );
              setTimeout(() => hideCalendar(), 200);
            }
          }
        }
      },
      [
        calendarMode,
        isRangeMode,
        dateRange,
        hideCalendar,
        scale,
        onDateSelect,
        onRangeSelect,
        isDateDisabled,
      ],
    );

    const navigateMonth = useCallback((direction: "prev" | "next") => {
      setCurrentMonth((prev) =>
        direction === "prev"
          ? prev.clone().subtract(1, "month")
          : prev.clone().add(1, "month"),
      );
    }, []);

    const handleModeChange = useCallback(
      (mode: CalendarMode) => {
        setCalendarMode(mode);
        onModeChange?.(mode);
        if (mode !== "date") {
          setIsRangeMode(false);
        }
      },
      [onModeChange],
    );

    const handleMonthSelect = useCallback(
      (monthIndex: number) => {
        const newMonth = currentMonth.clone().month(monthIndex);
        setCurrentMonth(newMonth);

        if (calendarMode === "month") {
          setSelectedDate(newMonth.format("YYYY-MM-DD"));
          onDateSelect?.(newMonth.format("YYYY-MM-DD"));
          setTimeout(() => hideCalendar(), 150);
        } else if (calendarMode === "month-year") {
        } else {
          setTimeout(() => setViewMode("day"), 100);
        }
      },
      [currentMonth, calendarMode, hideCalendar, onDateSelect],
    );

    const handleYearSelect = useCallback(
      (year: number) => {
        const newYear = currentMonth.clone().year(year);
        setCurrentMonth(newYear);

        if (calendarMode === "year") {
          setSelectedDate(newYear.format("YYYY-MM-DD"));
          onDateSelect?.(newYear.format("YYYY-MM-DD"));
          setTimeout(() => hideCalendar(), 150);
        } else {
          setTimeout(() => setViewMode("month"), 100);
        }
      },
      [currentMonth, calendarMode, hideCalendar, onDateSelect],
    );

    const handleTimeChange = useCallback(
      (type: "hour" | "minute" | "period", value: number | string) => {
        const newTime = { ...selectedTime, [type]: value };
        setSelectedTime(newTime);
        onTimeSelect?.(newTime);
      },
      [selectedTime, onTimeSelect],
    );

    const goToToday = useCallback(() => {
      const today = moment();

      if (isRangeMode) {
        const newRange = { start: today.format("YYYY-MM-DD"), end: null };
        setDateRange(newRange);
        onRangeSelect?.(newRange);
      } else {
        setSelectedDate(today.format("YYYY-MM-DD"));
        onDateSelect?.(today.format("YYYY-MM-DD"));
      }
      setCurrentMonth(today);
      setViewMode("day");
    }, [isRangeMode, onDateSelect, onRangeSelect]);

    const clearSelection = useCallback(() => {
      if (isRangeMode) {
        const clearedRange = { start: null, end: null };
        setDateRange(clearedRange);
        onRangeSelect?.(clearedRange);
      }
    }, [isRangeMode, onRangeSelect]);

    const resetSelection = useCallback(() => {
      setSelectedDate(initialDate);
      setDateRange({ start: null, end: null });
      setCurrentMonth(moment(initialDate));
      setViewMode("day");
    }, [initialDate]);

    const getValue = useCallback(() => {
      if (isRangeMode) {
        return dateRange;
      }
      return selectedDate;
    }, [isRangeMode, selectedDate, dateRange]);

    const setDateProgrammatically = useCallback(
      (date: string) => {
        setSelectedDate(date);
        setCurrentMonth(moment(date));
        onDateSelect?.(date);
      },
      [onDateSelect],
    );

    const setRangeProgrammatically = useCallback(
      (range: DateRange) => {
        setDateRange(range);
        onRangeSelect?.(range);
      },
      [onRangeSelect],
    );

    useImperativeHandle(
      ref,
      () => ({
        open: showCalendar,
        close: hideCalendar,
        reset: resetSelection,
        goToToday,
        getValue,
        setDate: setDateProgrammatically,
        setRange: setRangeProgrammatically,
      }),
      [
        showCalendar,
        hideCalendar,
        resetSelection,
        goToToday,
        getValue,
        setDateProgrammatically,
        setRangeProgrammatically,
      ],
    );

    const formatSelectedValue = useCallback(() => {
      const config = calendarModes[calendarMode];
      const format = dateFormat || config.format;

      if (isRangeMode && calendarMode === "date" && dateRange.start) {
        const start = moment(dateRange.start).format("MMM D, YYYY");
        const end = dateRange.end
          ? moment(dateRange.end).format("MMM D, YYYY")
          : "Select end date";
        return `${start} â€” ${end}`;
      }

      switch (calendarMode) {
        case "date":
          return moment(selectedDate).format(format);
        case "month":
          return currentMonth.format(format);
        case "year":
          return currentMonth.format(format);
        case "month-year":
          return currentMonth.format(format);
        case "time":
          const timeStr = `${selectedTime.hour}:${selectedTime.minute.toString().padStart(2, "0")} ${selectedTime.period}`;
          return `${moment(selectedDate).format("MMM D, YYYY")} ${timeStr}`;
        default:
          return moment(selectedDate).format(format);
      }
    }, [
      calendarMode,
      selectedDate,
      currentMonth,
      selectedTime,
      dateRange,
      isRangeMode,
      dateFormat,
    ]);

    const animatedStyle = useAnimatedStyle(() => ({
      opacity: opacity.value,
      transform: [{ translateY: translateY.value }, { scale: scale.value }],
    }));

    const getSheetTitle = () => {
      const config = calendarModes[calendarMode];
      return isRangeMode && calendarMode === "date"
        ? "Select Date Range"
        : config.title;
    };

    const renderDayView = useCallback(
      () => (
        <View style={styles.calendarContainer}>
          {/* Header */}
          <View style={styles.header}>
            <Pressable
              style={[styles.navButton, { backgroundColor: theme.muted }]}
              onPress={() => navigateMonth("prev")}
            >
              <SymbolView
                name="chevron.left"
                size={20}
                type="hierarchical"
                tintColor={theme.foreground}
              />
            </Pressable>

            <Pressable
              style={[
                styles.monthYearButton,
                { backgroundColor: theme.secondary },
              ]}
              onPress={() => setViewMode("month")}
            >
              <Text style={[styles.monthYearText, { color: theme.foreground }]}>
                {currentMonth.format("MMMM YYYY")}
              </Text>
            </Pressable>

            <Pressable
              style={[styles.navButton, { backgroundColor: theme.muted }]}
              onPress={() => navigateMonth("next")}
            >
              <SymbolView
                name="chevron.right"
                size={20}
                type="hierarchical"
                tintColor={theme.foreground}
              />
            </Pressable>
          </View>

          {/* Days header */}
          <View style={styles.daysHeader}>
            {["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"].map((day) => (
              <Text
                key={day}
                style={[styles.dayHeaderText, { color: theme.mutedForeground }]}
              >
                {day}
              </Text>
            ))}
          </View>

          {/* Calendar grid */}
          <View style={styles.calendarGrid}>
            {calendarDays.map((item) => (
              <CalendarDay
                key={item.date}
                item={item}
                onPress={handleDateSelect}
                theme={theme}
                disabled={
                  !item.isCurrentMonth ||
                  (calendarMode !== "date" && calendarMode !== "time") ||
                  isDateDisabled(item.date)
                }
              />
            ))}
          </View>

          {/* Time picker for time mode */}
          {calendarMode === "time" && (
            <TimePicker
              selectedTime={selectedTime}
              onTimeChange={handleTimeChange}
              theme={theme}
            />
          )}
        </View>
      ),
      [
        calendarDays,
        currentMonth,
        navigateMonth,
        setViewMode,
        handleDateSelect,
        theme,
        calendarMode,
        selectedTime,
        handleTimeChange,
        isDateDisabled,
      ],
    );

    const renderMonthView = useCallback(
      () => (
        <View style={styles.viewContainer}>
          <View style={styles.header}>
            <Pressable
              style={[styles.navButton, { backgroundColor: theme.muted }]}
              onPress={() =>
                calendarMode === "month" ? hideCalendar() : setViewMode("day")
              }
            >
              <SymbolView
                name="chevron.left"
                size={20}
                type="hierarchical"
                tintColor={theme.foreground}
              />
            </Pressable>

            <Pressable
              style={[
                styles.monthYearButton,
                { backgroundColor: theme.secondary },
              ]}
              onPress={() =>
                calendarMode !== "month" ? setViewMode("year") : undefined
              }
            >
              <Text style={[styles.monthYearText, { color: theme.foreground }]}>
                {currentMonth.year()}
              </Text>
            </Pressable>

            <View style={styles.navButton} />
          </View>

          <ScrollView
            showsVerticalScrollIndicator={false}
            scrollEventThrottle={16}
            removeClippedSubviews={true}
            contentContainerStyle={{ paddingVertical: 8 }}
          >
            <View style={styles.monthGrid}>
              {months.map((month, index) => (
                <MonthCell
                  key={month}
                  month={month}
                  index={index}
                  isSelected={currentMonth.month() === index}
                  onPress={handleMonthSelect}
                  theme={theme}
                />
              ))}
            </View>
          </ScrollView>
        </View>
      ),
      [
        months,
        currentMonth,
        handleMonthSelect,
        theme,
        calendarMode,
        hideCalendar,
        setViewMode,
      ],
    );

    const renderYearItem = useCallback(
      ({ item }: { item: number }) => (
        <ScrollView
          ref={scrollview}
          contentContainerStyle={{
            flexGrow: 1,
            justifyContent: "center",
            alignItems: "center",
          }}
          style={{ flex: 1 }}
          nestedScrollEnabled
        >
          <YearCell
            year={item}
            isSelected={currentMonth.year() === item}
            onPress={handleYearSelect}
            theme={theme}
          />
        </ScrollView>
      ),
      [currentMonth, handleYearSelect, theme],
    );

    const getYearItemLayout = useCallback(
      (data: any, index: number) => ({
        length: 76,
        offset: 76 * index,
        index,
      }),
      [],
    );

    const renderYearView = useCallback(
      () => (
        <View style={styles.viewContainer}>
          <View style={styles.header}>
            <Pressable
              style={[styles.navButton, { backgroundColor: theme.muted }]}
              onPress={() =>
                calendarMode === "year" ? hideCalendar() : setViewMode("month")
              }
            >
              <SymbolView
                name="chevron.left"
                size={20}
                type="hierarchical"
                tintColor={theme.foreground}
              />
            </Pressable>

            <Text style={[styles.monthYearText, { color: theme.foreground }]}>
              Select Year
            </Text>

            <View style={styles.navButton} />
          </View>

          {/* Year filter */}
          <View style={styles.filterContainer}>
            <View
              style={[
                styles.searchInputContainer,
                { borderColor: theme.border, backgroundColor: theme.input },
              ]}
            >
              <SymbolView
                name="magnifyingglass"
                size={18}
                type="hierarchical"
                tintColor={theme.mutedForeground}
                style={styles.searchIcon}
              />
              <TextInput
                style={[styles.filterInput, { color: theme.foreground }]}
                placeholder="Search years..."
                value={yearFilter}
                onChangeText={setYearFilter}
                keyboardType="numeric"
                placeholderTextColor={theme.mutedForeground}
              />
              {yearFilter.length > 0 && (
                <Pressable
                  style={styles.clearIcon}
                  onPress={() => setYearFilter("")}
                >
                  <SymbolView
                    name="xmark.circle.fill"
                    size={18}
                    type="hierarchical"
                    tintColor={theme.mutedForeground}
                  />
                </Pressable>
              )}
            </View>
          </View>

          <View style={styles.yearGridContainer}>
            <FlatList
              scrollEnabled={true}
              data={filteredYears}
              renderItem={renderYearItem}
              keyExtractor={(item) => item.toString()}
              numColumns={3}
              columnWrapperStyle={styles.yearRow}
              contentContainerStyle={styles.yearGridContent}
              showsVerticalScrollIndicator={false}
              removeClippedSubviews={true}
              maxToRenderPerBatch={15}
              windowSize={10}
              initialNumToRender={15}
              getItemLayout={getYearItemLayout}
            />
          </View>
        </View>
      ),
      [
        filteredYears,
        renderYearItem,
        getYearItemLayout,
        theme,
        calendarMode,
        hideCalendar,
        setViewMode,
        yearFilter,
      ],
    );

    const renderTriggerContent = () => {
      if (renderTrigger) {
        return renderTrigger({
          selectedValue: formatSelectedValue(),
          onPress: showCalendar,
          isRangeMode,
        });
      }

      return (
        <Pressable
          style={[
            styles.trigger,
            { borderColor: theme.border, backgroundColor: theme.background },
          ]}
          onPress={showCalendar}
        >
          <Text style={[styles.triggerText, { color: theme.foreground }]}>
            {formatSelectedValue()}
          </Text>
          <SymbolView
            name="calendar"
            size={22}
            type="hierarchical"
            tintColor={theme.mutedForeground}
          />
        </Pressable>
      );
    };

    return (
      <View style={[styles.container, { backgroundColor: theme.background }]}>
        {!hideTrigger && renderTriggerContent()}
        <TrueSheet
          blurTint="systemChromeMaterialDark"
          ref={sheet}
          scrollRef={scrollview}
          sizes={sheetSizes as any}
          cornerRadius={20}
        >
          <Animated.View
            style={[styles.sheet, {}, animatedStyle]}
            entering={FadeIn}
          >
            <Animated.View style={styles.sheetHeader}>
              <View style={styles.sheetTitleContainer}>
                <SymbolView
                  name="calendar.circle.fill"
                  size={24}
                  type="hierarchical"
                  tintColor={theme.primary}
                />
                <Text style={[styles.sheetTitle, { color: theme.foreground }]}>
                  {getSheetTitle()}
                </Text>
              </View>
              <View style={styles.sheetActions}>
                <Pressable
                  style={[
                    styles.actionButton,
                    { backgroundColor: theme.muted },
                  ]}
                  onPress={goToToday}
                >
                  <SymbolView
                    name="location.fill"
                    size={16}
                    type="hierarchical"
                    tintColor={theme.foreground}
                    style={styles.actionIcon}
                  />
                  <Text
                    style={[
                      styles.actionButtonText,
                      { color: theme.foreground },
                    ]}
                  >
                    Today
                  </Text>
                </Pressable>
                {isRangeMode && (dateRange.start || dateRange.end) && (
                  <Pressable
                    style={[
                      styles.clearButton,
                      {
                        backgroundColor: theme.destructive + "20",
                        borderColor: theme.destructive + "40",
                      },
                    ]}
                    onPress={clearSelection}
                  >
                    <SymbolView
                      name="trash.fill"
                      size={16}
                      type="hierarchical"
                      tintColor={theme.destructive}
                      style={styles.actionIcon}
                    />
                    <Text
                      style={[
                        styles.clearButtonText,
                        { color: theme.destructive },
                      ]}
                    >
                      Clear
                    </Text>
                  </Pressable>
                )}
              </View>
            </Animated.View>

            {/* Mode selector and range toggle */}
            {(showModeSelector || showRangeToggle) && (
              <View style={styles.controlsContainer}>
                {showModeSelector && (
                  <View
                    style={[
                      styles.modeSelector,
                      {
                        backgroundColor: theme.card,
                        borderColor: theme.border,
                      },
                    ]}
                  >
                    <View style={styles.modeSelectorHeader}>
                      <SymbolView
                        name="gear.circle.fill"
                        size={20}
                        type="hierarchical"
                        tintColor={theme.primary}
                      />
                      <Text
                        style={[
                          styles.switchLabel,
                          { color: theme.foreground },
                        ]}
                      >
                        Mode
                      </Text>
                    </View>
                    <View style={styles.modeButtons}>
                      {Object.keys(calendarModes).map((mode) => (
                        <Pressable
                          key={mode}
                          style={[
                            styles.modeButton,
                            {
                              backgroundColor:
                                calendarMode === mode
                                  ? theme.primary
                                  : theme.muted,
                              borderColor:
                                calendarMode === mode
                                  ? theme.primary
                                  : theme.border,
                            },
                          ]}
                          onPress={() => handleModeChange(mode as CalendarMode)}
                        >
                          <Text
                            style={[
                              styles.modeButtonText,
                              {
                                color:
                                  calendarMode === mode
                                    ? theme.primaryForeground
                                    : theme.foreground,
                              },
                            ]}
                          >
                            {calendarModes[mode as CalendarMode].title.replace(
                              "Select ",
                              "",
                            )}
                          </Text>
                        </Pressable>
                      ))}
                    </View>
                  </View>
                )}

                {showRangeToggle && calendarMode === "date" && (
                  <View
                    style={[
                      styles.switchContainer,
                      {
                        backgroundColor: theme.card,
                        borderColor: theme.border,
                      },
                    ]}
                  >
                    <View style={styles.switchLabelContainer}>
                      <SymbolView
                        name="calendar.badge.plus"
                        size={20}
                        type="hierarchical"
                        tintColor={theme.primary}
                      />
                      <Text
                        style={[
                          styles.switchLabel,
                          { color: theme.foreground },
                        ]}
                      >
                        Range Selection
                      </Text>
                    </View>
                    <Switch
                      value={isRangeMode}
                      onValueChange={setIsRangeMode}
                      trackColor={{ false: theme.muted, true: theme.primary }}
                      thumbColor={
                        isRangeMode ? theme.primaryForeground : theme.foreground
                      }
                    />
                  </View>
                )}
              </View>
            )}

            {viewMode === "day" && renderDayView()}
            {viewMode === "month" && renderMonthView()}
            {viewMode === "year" && renderYearView()}
          </Animated.View>
        </TrueSheet>
      </View>
    );

},
);

````

</Accordion>
</Accordions>

  </TabsContent>
</Tabs>

### ðŸš€ Example

```tsx
// EnhancedCalendarExample.tsx
import React, {
  useRef,
  useState,
  useCallback,
  useMemo,
  useEffect,
} from "react";
import {
  View,
  Text,
  StyleSheet,
  SafeAreaView,
  ScrollView,
  Pressable,
  StatusBar,
  Platform,
  Alert,
  Vibration,
} from "react-native";
import { LinearGradient } from "expo-linear-gradient";
import { SFSymbol, SymbolView } from "expo-symbols";
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
  withTiming,
  FadeInDown,
  FadeInUp,
  FadeIn,
  withSequence,
  withRepeat,
  interpolateColor,
} from "react-native-reanimated";
import {
  CalendarView,
  CalendarViewRef,
  DateRange,
} from "@/components/molecules/Calendar/index";

const theme = {
  background: "#0a0a0a",
  card: "#0f0f0f",
  cardHover: "#171717",
  foreground: "#fafafa",
  muted: "#171717",
  mutedForeground: "#737373",
  border: "#262626",
  primary: "#fafafa",
  primaryForeground: "#0a0a0a",
  secondary: "#1a1a1a",
  accent: "#fafafa",
  accentForeground: "#0a0a0a",
  success: "#22c55e",
  warning: "#f59e0b",
  destructive: "#ef4444",
  info: "#06b6d4",
  purple: "#8b5cf6",
  orange: "#f97316",
  alarm: "#ff6b6b",
  alarmLight: "#ff8e8e",
  gradients: {
    primary: ["#0a0a0a", "#171717"],
    accent: ["#fafafa", "#a3a3a3"],
    success: ["#22c55e", "#16a34a"],
    purple: ["#8b5cf6", "#7c3aed"],
    orange: ["#f97316", "#ea580c"],
    blue: ["#3b82f6", "#1d4ed8"],
    alarm: ["black", "black"],
    alarmDark: ["#2c2c2c", "#1a1a1a"],
  },
};

interface CalendarDemo {
  id: string;
  title: string;
  description: string;
  icon: string;
  color: string;
  config: any;
}

interface AlertItem {
  id: string;
  date: string;
  time?: string;
  title: string;
  type: "reminder" | "event" | "deadline" | "meeting";
  isActive: boolean;
}

const calendarDemos: CalendarDemo[] = [
  {
    id: "date",
    title: "Date Picker",
    description: "Single date selection with alarm alerts",
    icon: "calendar.circle.fill",
    color: theme.accent,
    config: {
      initialMode: "date",
      enableRangeMode: false,
      showModeSelector: false,
      showRangeToggle: false,
    },
  },
  {
    id: "range",
    title: "Date Range",
    description: "Period selection with smart notifications",
    icon: "calendar.badge.plus",
    color: theme.success,
    config: {
      initialMode: "date",
      enableRangeMode: true,
      showModeSelector: false,
      showRangeToggle: false,
    },
  },
  {
    id: "time",
    title: "Date & Time",
    description: "Precision scheduling with alarm system",
    icon: "alarm.fill",
    color: theme.alarm,
    config: {
      initialMode: "time",
      enableRangeMode: false,
      showModeSelector: false,
      showRangeToggle: false,
    },
  },
  {
    id: "full",
    title: "Smart Scheduler",
    description: "Complete alarm & notification system",
    icon: "bell.badge.fill",
    color: theme.orange,
    config: {
      initialMode: "date",
      enableRangeMode: false,
      showModeSelector: true,
      showRangeToggle: true,
    },
  },
];

const DemoCard = React.memo<{
  demo: CalendarDemo;
  index: number;
  isSelected: boolean;
  onSelect: (id: string) => void;
}>(({ demo, index, isSelected, onSelect }) => {
  const pulseAnim = useSharedValue(1);
  const glowAnim = useSharedValue(0);

  useEffect(() => {
    if (isSelected) {
      pulseAnim.value = withRepeat(
        withSequence(
          withTiming(1.02, { duration: 1000 }),
          withTiming(1, { duration: 1000 }),
        ),
        -1,
        true,
      );
      glowAnim.value = withRepeat(
        withSequence(
          withTiming(1, { duration: 2000 }),
          withTiming(0, { duration: 2000 }),
        ),
        -1,
        true,
      );
    } else {
      pulseAnim.value = withTiming(1);
      glowAnim.value = withTiming(0);
    }
  }, [isSelected]);

  const handlePress = useCallback(() => {
    onSelect(demo.id);
    Vibration.vibrate(50);
  }, [demo.id, onSelect]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: pulseAnim.value }],
    shadowOpacity: 0.1 + glowAnim.value * 0.3,
  }));

  const glowStyle = useAnimatedStyle(() => ({
    opacity: glowAnim.value * 0.3,
    backgroundColor: interpolateColor(
      glowAnim.value,
      [0, 1],
      ["transparent", demo.color + "20"],
    ),
  }));

  return (
    <Animated.View
      entering={FadeInDown.delay(index * 100)}
      style={[
        styles.demoCard,
        animatedStyle,
        {
          borderColor: isSelected ? demo.color : theme.border,
          borderWidth: isSelected ? 2 : 1,
        },
      ]}
    >
      {isSelected && <Animated.View style={[styles.cardGlow, glowStyle]} />}
      <Pressable style={styles.cardContent} onPress={handlePress}>
        <View style={styles.cardHeader}>
          <View
            style={[
              styles.iconContainer,
              { backgroundColor: demo.color + "20" },
            ]}
          >
            <SymbolView
              name={demo.icon as SFSymbol}
              size={24}
              type="hierarchical"
              tintColor={demo.color}
            />
          </View>
          <Text style={[styles.cardTitle, { color: theme.foreground }]}>
            {demo.title}
          </Text>
        </View>
        <Text
          style={[styles.cardDescription, { color: theme.mutedForeground }]}
        >
          {demo.description}
        </Text>

        {isSelected && (
          <Animated.View
            entering={FadeIn.duration(200)}
            style={styles.selectedIndicator}
          >
            <SymbolView
              name="checkmark.circle.fill"
              size={20}
              type="hierarchical"
              tintColor={demo.color}
            />
          </Animated.View>
        )}
      </Pressable>
    </Animated.View>
  );
});

const AlertCard = React.memo<{
  alert: AlertItem;
  onToggle: (id: string) => void;
  onDelete: (id: string) => void;
}>(({ alert, onToggle, onDelete }) => {
  const pulseAnim = useSharedValue(1);

  useEffect(() => {
    if (alert.isActive) {
      pulseAnim.value = withRepeat(
        withSequence(
          withTiming(1.01, { duration: 1500 }),
          withTiming(1, { duration: 1500 }),
        ),
        -1,
        true,
      );
    } else {
      pulseAnim.value = withTiming(1);
    }
  }, [alert.isActive]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ scale: pulseAnim.value }],
  }));

  const getAlertIcon = () => {
    switch (alert.type) {
      case "reminder":
        return "bell.fill";
      case "event":
        return "calendar.circle.fill";
      case "deadline":
        return "exclamationmark.triangle.fill";
      case "meeting":
        return "person.2.fill";
      default:
        return "bell.fill";
    }
  };

  const getAlertColor = () => {
    switch (alert.type) {
      case "reminder":
        return theme.info;
      case "event":
        return theme.success;
      case "deadline":
        return theme.alarm;
      case "meeting":
        return theme.purple;
      default:
        return theme.info;
    }
  };

  return (
    <Animated.View style={[styles.alertCard, animatedStyle]}>
      <LinearGradient
        colors={
          alert.isActive
            ? theme.gradients.alarm
            : (theme.gradients.alarmDark as any)
        }
        style={styles.alertGradient}
      >
        <View style={styles.alertContent}>
          <View style={styles.alertLeft}>
            <View
              style={[
                styles.alertIcon,
                { backgroundColor: getAlertColor() + "20" },
              ]}
            >
              <SymbolView
                name={getAlertIcon() as SFSymbol}
                size={18}
                type="hierarchical"
                tintColor={getAlertColor()}
              />
            </View>
            <View style={styles.alertTextContainer}>
              <Text style={[styles.alertTitle, { color: theme.foreground }]}>
                {alert.title}
              </Text>
              <Text
                style={[styles.alertDate, { color: theme.mutedForeground }]}
              >
                {alert.date} {alert.time && `at ${alert.time}`}
              </Text>
            </View>
          </View>
          <View style={styles.alertActions}>
            <Pressable
              style={[
                styles.alertToggle,
                {
                  backgroundColor: alert.isActive
                    ? theme.success + "20"
                    : theme.muted,
                },
              ]}
              onPress={() => onToggle(alert.id)}
            >
              <SymbolView
                name={alert.isActive ? "bell.fill" : "bell.slash.fill"}
                size={14}
                type="hierarchical"
                tintColor={
                  alert.isActive ? theme.success : theme.mutedForeground
                }
              />
            </Pressable>
            <Pressable
              style={[
                styles.alertDelete,
                { backgroundColor: theme.destructive + "20" },
              ]}
              onPress={() => onDelete(alert.id)}
            >
              <SymbolView
                name="trash.fill"
                size={14}
                type="hierarchical"
                tintColor={theme.destructive}
              />
            </Pressable>
          </View>
        </View>
      </LinearGradient>
    </Animated.View>
  );
});

const ActionButton = React.memo<{
  title: string;
  icon: string;
  onPress: () => void;
  variant?: "default" | "destructive" | "success" | "alarm";
}>(({ title, icon, onPress, variant = "default" }) => {
  const colors = useMemo(
    () => ({
      default: {
        bg: theme.secondary,
        text: theme.foreground,
        icon: theme.foreground,
      },
      destructive: {
        bg: theme.destructive + "15",
        text: theme.destructive,
        icon: theme.destructive,
      },
      success: {
        bg: theme.success + "15",
        text: theme.success,
        icon: theme.success,
      },
      alarm: {
        bg: theme.alarm + "15",
        text: theme.alarm,
        icon: theme.alarm,
      },
    }),
    [],
  );

  const buttonStyle = useMemo(
    () => [
      styles.actionButton,
      {
        backgroundColor: colors[variant].bg,
        borderColor: colors[variant].text + "20",
      },
    ],
    [colors, variant],
  );

  return (
    <Pressable style={buttonStyle} onPress={onPress}>
      <SymbolView
        name={icon as SFSymbol}
        size={14}
        type="hierarchical"
        tintColor={colors[variant].icon}
      />
      <Text style={[styles.actionButtonText, { color: colors[variant].text }]}>
        {title}
      </Text>
    </Pressable>
  );
});

const EnhancedCalendarExample: React.FC = () => {
  const calendarRefs = useRef<{ [key: string]: CalendarViewRef | null }>({});
  const [selectedValues, setSelectedValues] = useState<{
    [key: string]: string;
  }>({});
  const [selectedDemo, setSelectedDemo] = useState<string>("date");
  const [alerts, setAlerts] = useState<AlertItem[]>([
    {
      id: "1",
      date: "Today",
      time: "10:30 AM",
      title: "Team Meeting",
      type: "meeting",
      isActive: true,
    },
    {
      id: "2",
      date: "Tomorrow",
      title: "Project Deadline",
      type: "deadline",
      isActive: true,
    },
  ]);

  const headerScale = useSharedValue(1);
  const alarmPulse = useSharedValue(1);

  useEffect(() => {
    alarmPulse.value = withRepeat(
      withSequence(
        withTiming(1.1, { duration: 1000 }),
        withTiming(1, { duration: 1000 }),
      ),
      -1,
      true,
    );
  }, []);

  const handleDemoSelect = useCallback((demoId: string) => {
    setSelectedDemo(demoId);
    Vibration.vibrate(50);
  }, []);

  const handleDateSelect = useCallback(
    (demoId: string) => (date: string) => {
      setSelectedValues((prev) => ({ ...prev, [demoId]: date }));

      Alert.alert("ðŸ“… Date Selected", `Selected date: ${date}`, [
        {
          text: "Set Reminder",
          onPress: () => addAlert(date, "reminder"),
        },
        {
          text: "OK",
          style: "default",
        },
      ]);

      headerScale.value = withSpring(1.01, { damping: 20 }, () => {
        headerScale.value = withSpring(1);
      });
      Vibration.vibrate(100);
    },
    [],
  );

  const handleRangeSelect = useCallback(
    (demoId: string) => (range: DateRange) => {
      const rangeText = range.start
        ? `${range.start}${range.end ? ` to ${range.end}` : " (select end)"}`
        : "No range selected";
      setSelectedValues((prev) => ({ ...prev, [demoId]: rangeText }));

      if (range.start && range.end) {
        Alert.alert(
          "ðŸ“Š Range Selected",
          `Period: ${range.start} to ${range.end}`,
          [
            {
              text: "Set Period Alert",
              onPress: () => addAlert(rangeText, "event"),
            },
            {
              text: "OK",
              style: "default",
            },
          ],
        );
        Vibration.vibrate([100, 50, 100]);
      }
    },
    [],
  );

  const handleTimeSelect = useCallback(
    (demoId: string) =>
      (time: { hour: number; minute: number; period: string }) => {
        const timeText = `${time.hour}:${time.minute.toString().padStart(2, "0")} ${time.period}`;
        const fullDateTime = `${selectedValues[demoId]?.split(" at ")[0] || "Today"} at ${timeText}`;
        setSelectedValues((prev) => ({
          ...prev,
          [demoId]: fullDateTime,
        }));

        Alert.alert("â° Time Set", `Scheduled for: ${fullDateTime}`, [
          {
            text: "Set Alarm",
            onPress: () => addAlert("Today", "reminder", timeText),
          },
          {
            text: "OK",
            style: "default",
          },
        ]);
        Vibration.vibrate([50, 100, 50]);
      },
    [selectedValues],
  );

  const addAlert = useCallback(
    (date: string, type: AlertItem["type"], time?: string) => {
      const newAlert: AlertItem = {
        id: Date.now().toString(),
        date,
        time,
        title: `${type.charAt(0).toUpperCase() + type.slice(1)} for ${date}`,
        type,
        isActive: true,
      };
      setAlerts((prev) => [...prev, newAlert]);
      Vibration.vibrate(200);
    },
    [],
  );

  const toggleAlert = useCallback((id: string) => {
    setAlerts((prev) =>
      prev.map((alert) =>
        alert.id === id ? { ...alert, isActive: !alert.isActive } : alert,
      ),
    );
    Vibration.vibrate(50);
  }, []);

  const deleteAlert = useCallback((id: string) => {
    Alert.alert("Delete Alert", "Are you sure you want to delete this alert?", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Delete",
        style: "destructive",
        onPress: () => {
          setAlerts((prev) => prev.filter((alert) => alert.id !== id));
          Vibration.vibrate(100);
        },
      },
    ]);
  }, []);

  const openCalendar = useCallback(() => {
    calendarRefs.current[selectedDemo]?.open();
    Vibration.vibrate(50);
  }, [selectedDemo]);

  const goToToday = useCallback(() => {
    calendarRefs.current[selectedDemo]?.goToToday();
    Vibration.vibrate(50);
  }, [selectedDemo]);

  const resetCalendar = useCallback(() => {
    calendarRefs.current[selectedDemo]?.reset();
    setSelectedValues((prev) => ({ ...prev, [selectedDemo]: "" }));
    Vibration.vibrate(100);
  }, [selectedDemo]);

  const selectedDemoConfig = useMemo(
    () => calendarDemos.find((d) => d.id === selectedDemo),
    [selectedDemo],
  );

  const animatedHeaderStyle = useAnimatedStyle(() => ({
    transform: [{ scale: headerScale.value }],
  }));

  const animatedAlarmStyle = useAnimatedStyle(() => ({
    transform: [{ scale: alarmPulse.value }],
  }));

  const renderCustomTrigger = useCallback(
    ({
      selectedValue,
      onPress,
      isRangeMode,
    }: {
      selectedValue: string;
      onPress: () => void;
      isRangeMode: boolean;
    }) => (
      <Pressable
        style={[
          styles.customTrigger,
          {
            backgroundColor: theme.card,
            borderColor: selectedDemoConfig?.color || theme.border,
          },
        ]}
        onPress={onPress}
      >
        <LinearGradient
          colors={theme.gradients.alarmDark as any}
          style={styles.triggerGradient}
        >
          <View style={styles.triggerContent}>
            <View style={styles.triggerLeft}>
              <View
                style={[
                  styles.triggerIcon,
                  {
                    backgroundColor:
                      selectedDemoConfig?.color + "20" || theme.muted,
                  },
                ]}
              >
                <SymbolView
                  name={(selectedDemoConfig?.icon as SFSymbol) || "calendar"}
                  size={18}
                  type="hierarchical"
                  tintColor={selectedDemoConfig?.color || theme.accent}
                />
              </View>
              <View style={styles.triggerTextContainer}>
                <Text
                  style={[
                    styles.triggerLabel,
                    { color: theme.mutedForeground },
                  ]}
                >
                  {isRangeMode
                    ? "DATE RANGE"
                    : selectedDemoConfig?.title.toUpperCase()}
                </Text>
                <Text
                  style={[styles.triggerValue, { color: theme.foreground }]}
                >
                  {selectedValue || "Select date..."}
                </Text>
              </View>
            </View>
            <SymbolView
              name="chevron.right"
              size={14}
              type="hierarchical"
              tintColor={theme.mutedForeground}
            />
          </View>
        </LinearGradient>
      </Pressable>
    ),
    [selectedDemoConfig],
  );

  const features = useMemo(
    () => [
      {
        icon: "bell.badge.fill",
        title: "Smart Alerts",
        desc: "Intelligent notification system",
      },
      {
        icon: "alarm.fill",
        title: "Precision Timing",
        desc: "Exact time scheduling",
      },
      {
        icon: "calendar.badge.plus",
        title: "Range Selection",
        desc: "Intuitive date range picking",
      },
      {
        icon: "paintbrush.fill",
        title: "Alarm Theme",
        desc: "Beautiful dark alarm aesthetic",
      },
      {
        icon: "wand.and.rays",
        title: "Smooth Animations",
        desc: "Reanimated 3 transitions",
      },
      {
        icon: "hand.tap.fill",
        title: "Haptic Feedback",
        desc: "Rich tactile responses",
      },
    ],
    [],
  );

  return (
    <ScrollView
      showsVerticalScrollIndicator={false}
      contentContainerStyle={{ flexGrow: 1 }}
      style={{ flex: 1 }}
      scrollEnabled={true}
      contentInsetAdjustmentBehavior="always"
    >
      <SafeAreaView
        style={[styles.container, { backgroundColor: theme.background }]}
      >
        <StatusBar
          barStyle="light-content"
          backgroundColor={theme.background}
        />

        <Animated.View entering={FadeInUp} style={styles.header}>
          <LinearGradient
            colors={theme?.gradients?.alarm as any}
            style={styles.headerGradient}
          >
            <Animated.View style={[styles.headerContent, animatedHeaderStyle]}>
              <View style={styles.headerTitleContainer}>
                <Animated.View
                  style={[styles.headerIconContainer, animatedAlarmStyle]}
                >
                  <SymbolView
                    name="alarm.fill"
                    size={28}
                    type="hierarchical"
                    tintColor={"white"}
                  />
                </Animated.View>
                <View>
                  <Text style={[styles.headerTitle, { color: "white" }]}>
                    Smart Calendar
                  </Text>
                  <Text
                    style={[
                      styles.headerSubtitle,
                      { color: theme.mutedForeground },
                    ]}
                  >
                    Intelligent scheduling with alerts
                  </Text>
                </View>
              </View>
            </Animated.View>
          </LinearGradient>
        </Animated.View>

        <ScrollView
          showsHorizontalScrollIndicator={false}
          style={styles.scrollView}
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
        >
          <Animated.View entering={FadeInUp.delay(100)} style={styles.section}>
            <View style={styles.sectionHeader}>
              <SymbolView
                name="bell.badge.fill"
                size={20}
                type="hierarchical"
                tintColor={theme.alarm}
              />
              <Text style={[styles.sectionTitle, { color: theme.foreground }]}>
                Active Alerts ({alerts.filter((a) => a.isActive).length})
              </Text>
            </View>

            <View style={styles.alertsList}>
              {alerts.map((alert) => (
                <AlertCard
                  key={alert.id}
                  alert={alert}
                  onToggle={toggleAlert}
                  onDelete={deleteAlert}
                />
              ))}
              {alerts.length === 0 && (
                <View style={styles.emptyState}>
                  <SymbolView
                    name="bell.slash"
                    size={32}
                    type="hierarchical"
                    tintColor={theme.mutedForeground}
                  />
                  <Text
                    style={[styles.emptyText, { color: theme.mutedForeground }]}
                  >
                    No alerts set
                  </Text>
                </View>
              )}
            </View>
          </Animated.View>

          <Animated.View entering={FadeInUp.delay(200)} style={styles.section}>
            <View style={styles.sectionHeader}>
              <SymbolView
                name="square.grid.2x2.fill"
                size={20}
                type="hierarchical"
                tintColor={theme.accent}
              />
              <Text style={[styles.sectionTitle, { color: theme.foreground }]}>
                Choose Demo
              </Text>
            </View>

            <View style={styles.demoGrid}>
              {calendarDemos.map((demo, index) => (
                <DemoCard
                  key={demo.id}
                  demo={demo}
                  index={index}
                  isSelected={selectedDemo === demo.id}
                  onSelect={handleDemoSelect}
                />
              ))}
            </View>
          </Animated.View>

          {selectedDemoConfig && (
            <Animated.View
              entering={FadeInUp.delay(300)}
              style={styles.section}
            >
              <View style={styles.sectionHeader}>
                <SymbolView
                  name="slider.horizontal.3"
                  size={20}
                  type="hierarchical"
                  tintColor={selectedDemoConfig.color}
                />
                <Text
                  style={[styles.sectionTitle, { color: theme.foreground }]}
                >
                  {selectedDemoConfig.title} Demo
                </Text>
              </View>

              <View
                style={[
                  styles.calendarContainer,
                  {
                    backgroundColor: theme.card,
                    borderColor: theme.border,
                  },
                ]}
              >
                <CalendarView
                  ref={(ref) => (calendarRefs.current[selectedDemo] = ref)}
                  {...selectedDemoConfig.config}
                  onDateSelect={handleDateSelect(selectedDemo)}
                  onRangeSelect={handleRangeSelect(selectedDemo)}
                  onTimeSelect={handleTimeSelect(selectedDemo)}
                  theme={{
                    accent: selectedDemoConfig.color,
                    primary: selectedDemoConfig.color,
                    info: selectedDemoConfig.color,
                  }}
                  maxDate=""
                  renderTrigger={renderCustomTrigger}
                />

                {/* Enhanced Action Buttons */}
                <View style={styles.actionGrid}>
                  <ActionButton
                    title="Open"
                    icon="calendar"
                    onPress={openCalendar}
                  />
                  <ActionButton
                    title="Today"
                    icon="location.fill"
                    onPress={goToToday}
                    variant="success"
                  />
                  <ActionButton
                    title="Alert"
                    icon="bell.badge.fill"
                    onPress={() => addAlert("Today", "reminder")}
                    variant="alarm"
                  />
                  <ActionButton
                    title="Reset"
                    icon="arrow.counterclockwise"
                    onPress={resetCalendar}
                    variant="destructive"
                  />
                </View>
              </View>
            </Animated.View>
          )}

          <Animated.View entering={FadeInUp.delay(400)} style={styles.section}>
            <View style={styles.sectionHeader}>
              <SymbolView
                name="star.fill"
                size={20}
                type="hierarchical"
                tintColor={theme.warning}
              />
              <Text style={[styles.sectionTitle, { color: theme.foreground }]}>
                Features
              </Text>
            </View>

            <View style={styles.featuresList}>
              {features.map((feature, index) => (
                <Animated.View
                  key={feature.title}
                  entering={FadeInUp.delay(600 + index * 50)}
                  style={[
                    styles.featureItem,
                    {
                      backgroundColor: theme.card,
                      borderColor: theme.border,
                    },
                  ]}
                >
                  <View
                    style={[
                      styles.featureIcon,
                      { backgroundColor: theme.accent + "15" },
                    ]}
                  >
                    <SymbolView
                      name={feature.icon as SFSymbol}
                      size={18}
                      type="hierarchical"
                      tintColor={theme.accent}
                    />
                  </View>
                  <View style={styles.featureContent}>
                    <Text
                      style={[styles.featureTitle, { color: theme.foreground }]}
                    >
                      {feature.title}
                    </Text>
                    <Text
                      style={[
                        styles.featureDesc,
                        { color: theme.mutedForeground },
                      ]}
                    >
                      {feature.desc}
                    </Text>
                  </View>
                </Animated.View>
              ))}
            </View>
          </Animated.View>

          <Animated.View entering={FadeInUp.delay(500)} style={styles.section}>
            <View style={styles.sectionHeader}>
              <SymbolView
                name="doc.text.fill"
                size={20}
                type="hierarchical"
                tintColor={theme.info}
              />
              <Text style={[styles.sectionTitle, { color: theme.foreground }]}>
                Usage Example
              </Text>
            </View>

            <View
              style={[
                styles.codeContainer,
                {
                  backgroundColor: theme.card,
                  borderColor: theme.border,
                },
              ]}
            >
              <Text style={[styles.codeText, { color: theme.mutedForeground }]}>
                {`import { EnhancedCalendarView } from '@/components';

<EnhancedCalendarView
  initialMode="date"
  enableAlerts={true}
  onDateSelect={(date) => showAlert(date)}
  onAlertCreate={(alert) => console.log(alert)}
  theme={{
    accent: "#ff6b6b",
    alarmColor: "#ff4757"
  }}
/>`}
              </Text>
            </View>
          </Animated.View>
        </ScrollView>
      </SafeAreaView>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },

  header: {
    marginBottom: 8,
  },
  headerGradient: {
    paddingTop: 20,
    paddingBottom: 30,
    paddingHorizontal: 24,
  },
  headerContent: {
    gap: 16,
  },
  headerTitleContainer: {
    flexDirection: "row",
    alignItems: "center",
    gap: 16,
  },
  headerIconContainer: {
    width: 56,
    height: 56,
    borderRadius: 16,
    backgroundColor: "rgba(255, 255, 255, 0.1)",
    justifyContent: "center",
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 8,
  },
  headerTitle: {
    fontSize: 28,
    fontWeight: "900",
    letterSpacing: -0.5,
  },
  headerSubtitle: {
    fontSize: 15,
    fontWeight: "500",
    marginTop: 2,
  },

  scrollView: {
    flex: 1,
  },
  scrollContent: {
    paddingHorizontal: 24,
    paddingBottom: 40,
  },

  section: {
    marginBottom: 32,
    marginTop: 16,
  },
  sectionHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: "800",
    letterSpacing: 0.3,
  },

  alertsList: {
    gap: 12,
  },
  alertCard: {
    borderRadius: 16,
    overflow: "hidden",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
  },
  alertGradient: {
    padding: 16,
  },
  alertContent: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  alertLeft: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    flex: 1,
  },
  alertIcon: {
    width: 40,
    height: 40,
    borderRadius: 12,
    justifyContent: "center",
    alignItems: "center",
  },
  alertTextContainer: {
    flex: 1,
  },
  alertTitle: {
    fontSize: 16,
    fontWeight: "600",
    marginBottom: 2,
  },
  alertDate: {
    fontSize: 14,
    fontWeight: "500",
  },
  alertActions: {
    flexDirection: "row",
    gap: 8,
  },
  alertToggle: {
    width: 36,
    height: 36,
    borderRadius: 10,
    justifyContent: "center",
    alignItems: "center",
  },
  alertDelete: {
    width: 36,
    height: 36,
    borderRadius: 10,
    justifyContent: "center",
    alignItems: "center",
  },

  emptyState: {
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: 40,
    gap: 12,
  },
  emptyText: {
    fontSize: 16,
    fontWeight: "500",
  },

  demoGrid: {
    flexDirection: "row",
    flexWrap: "wrap",
    gap: 16,
  },
  demoCard: {
    width: "47%",
    borderRadius: 18,
    overflow: "hidden",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.15,
    shadowRadius: 16,
    elevation: 8,
    position: "relative",
  },
  cardGlow: {
    position: "absolute",
    top: -2,
    left: -2,
    right: -2,
    bottom: -2,
    borderRadius: 20,
    zIndex: -1,
  },

  cardContent: {
    backgroundColor: "#0a0a0a",
    padding: 20,
    borderRadius: 16,
    minHeight: 130,
    position: "relative",
  },
  cardHeader: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginBottom: 8,
  },
  iconContainer: {
    width: 42,
    height: 42,
    borderRadius: 12,
    justifyContent: "center",
    alignItems: "center",
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: "700",
    letterSpacing: 0.3,
    flex: 1,
  },
  cardDescription: {
    fontSize: 14,
    lineHeight: 20,
    marginTop: 4,
  },
  selectedIndicator: {
    position: "absolute",
    top: 16,
    right: 16,
  },

  calendarContainer: {
    borderRadius: 18,
    borderWidth: 1,
    padding: 24,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 6 },
    shadowOpacity: 0.15,
    shadowRadius: 16,
    elevation: 8,
  },

  customTrigger: {
    borderRadius: 14,
    borderWidth: 2,
    marginBottom: 20,
    overflow: "hidden",
  },
  triggerGradient: {
    padding: 18,
  },
  triggerContent: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  triggerLeft: {
    flexDirection: "row",
    alignItems: "center",
    gap: 14,
    flex: 1,
  },
  triggerIcon: {
    width: 40,
    height: 40,
    borderRadius: 12,
    justifyContent: "center",
    alignItems: "center",
  },
  triggerTextContainer: {
    flex: 1,
  },
  triggerLabel: {
    fontSize: 13,
    fontWeight: "600",
    marginBottom: 3,
    textTransform: "uppercase",
    letterSpacing: 0.5,
  },
  triggerValue: {
    fontSize: 16,
    fontWeight: "600",
  },

  actionGrid: {
    flexDirection: "row",
    gap: 10,
    marginTop: 8,
  },
  actionButton: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    gap: 8,
    paddingVertical: 12,
    paddingHorizontal: 16,
    borderRadius: 12,
    borderWidth: 1.5,
  },
  actionButtonText: {
    fontSize: 13,
    fontWeight: "700",
    letterSpacing: 0.3,
  },

  featuresList: {
    gap: 12,
  },
  featureItem: {
    flexDirection: "row",
    alignItems: "center",
    padding: 18,
    borderRadius: 16,
    borderWidth: 1,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 4,
  },
  featureIcon: {
    width: 40,
    height: 40,
    borderRadius: 12,
    justifyContent: "center",
    alignItems: "center",
    marginRight: 16,
  },
  featureContent: {
    flex: 1,
  },
  featureTitle: {
    fontSize: 16,
    fontWeight: "700",
    marginBottom: 4,
    letterSpacing: 0.2,
  },
  featureDesc: {
    fontSize: 13,
    lineHeight: 18,
    fontWeight: "500",
  },

  codeContainer: {
    borderRadius: 16,
    borderWidth: 1,
    padding: 20,
    backgroundColor: "#050505",
  },
  codeText: {
    fontFamily: Platform.OS === "ios" ? "Menlo" : "monospace",
    fontSize: 13,
    lineHeight: 20,
    color: "#a3a3a3",
  },
});

export default EnhancedCalendarExample;
````
